<HTML>
<HEAD><TITLE>The ref package</TITLE></HEAD>
<BODY>

<DL>
<dt><pre>
<A NAME="Ref_CheckAtomRefinement"></A>
boolean <I></I>
<B>Ref_CheckAtomRefinement</B>(
  Mdl_Manager_t * <b>mdlManager</b>, <i></i>
  Mdl_Module_t * <b>spec</b>, <i></i>
  Atm_Atom_t * <b>specAtom</b>, <i></i>
  Mdl_Module_t * <b>impl</b>, <i></i>
  lsList  <b>varNameList</b>, <i></i>
  lsList  <b>forceVarNameList</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  boolean  <b>checkRef</b>, <i></i>
  boolean  <b>verbose</b>, <i></i>
  boolean  <b>keepIntermediate</b>, <i></i>
  int  <b>impBoundary</b>, <i></i>
  boolean  <b>checkAtEnd</b>, <i></i>
  char * <b>orderFileName</b> <i></i>
)
</pre>
<dd> Given implementation, specification and and atom atom1 in implementation,
                       construct new modules newimplementation and newspecification
                       such that
                          1. new implementation contains atom1 only
                          2. new specification contains heuristically chosen atoms
                             from specification and implementation that control variables
                             controlled by atom1, but do not include atom1 itself
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_CheckImplCompatibility"></A>
boolean <I></I>
<B>Ref_CheckImplCompatibility</B>(
  Mdl_Module_t * <b>spec</b>, <i></i>
  Mdl_Module_t * <b>impl</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_CheckNohiddenRefinement"></A>
boolean <I></I>
<B>Ref_CheckNohiddenRefinement</B>(
  Mdl_Module_t * <b>implModule</b>, <i></i>
  Sym_Info_t * <b>implSymInfo</b>, <i></i>
  Mdl_Module_t * <b>specModule</b>, <i></i>
  Sym_Info_t * <b>specSymInfo</b>, <i></i>
  boolean  <b>verbose</b>, <i></i>
  boolean  <b>checkAtEnd</b> <i></i>
)
</pre>
<dd> Currently all variables of specModule need to be present in implModule
  
  The algorithm for doing this is as follows:
  -- First check if the initial states of specModule are contained in implModule
     If not FAIL
  
   -- do reachability of implModule
       During each stage of reachability 
             1. restrict trans relation of implModule to states in the frontier (ie build (frontier & implTrans))
             2. If restricted implementation trans does NOT imply specification trans, then FAIL and print error trace

   -- If reachability completes, PASS
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_CheckSimulationUsingPre"></A>
boolean <I></I>
<B>Ref_CheckSimulationUsingPre</B>(
  Mdl_Module_t * <b>implModule</b>, <i></i>
  Sym_Info_t * <b>implSymInfo</b>, <i></i>
  Mdl_Module_t * <b>specModule</b>, <i></i>
  Sym_Info_t * <b>specSymInfo</b>, <i></i>
  boolean  <b>verbose</b> <i></i>
)
</pre>
<dd> Check if specModule is a simulates of implModule
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_End"></A>
int <I></I>
<B>Ref_End</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_Init"></A>
int <I></I>
<B>Ref_Init</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_IsMemberOfAtomList"></A>
boolean <I></I>
<B>Ref_IsMemberOfAtomList</B>(
  lsList  <b>atomList</b>, <i></i>
  Atm_Atom_t * <b>atom</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_IsMemberOfNameList"></A>
boolean <I></I>
<B>Ref_IsMemberOfNameList</B>(
  lsList  <b>nameList</b>, <i></i>
  char * <b>name</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_LookupVarList"></A>
Var_Variable_t * <I></I>
<B>Ref_LookupVarList</B>(
  lsList  <b>varList</b>, <i></i>
  char * <b>name</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_Reinit"></A>
int <I></I>
<B>Ref_Reinit</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Ref_VariableReadControlAtom"></A>
Atm_Atom_t * <I></I>
<B>Ref_VariableReadControlAtom</B>(
  Var_Variable_t * <b>var</b> <i></i>
)
</pre>
<dd> Given a variable, get its controlling atom.
                      This differs from Var_VariableReadControllingAtom
		      in that it also works for array and bit-vector variables.
		      In the case of arrays and bit-vectors (or arrays of bit vectors)
		      the atom controlling the first element is returned.
<p>

<dd> <b>See Also</b> <code><a href="#Var_VariableReadControlAtom">Var_VariableReadControlAtom</a>
</code>


</DL>
<HR>
Last updated on 1031103 12h03
</BODY></HTML>
