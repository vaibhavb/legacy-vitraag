/**CHeaderFile*****************************************************************

  FileName    [sym.h]

  PackageName [sym]

  Synopsis    [building symbolic transition relation for a module ]

  Description [This package contains routines to build the symbolic transition
               relation for a module. The task of building the transition
               relation has two main components:
               1. Selecting a good variable ordering for the BDD package.
               2. Parititioning the transition relation
               Currently, simple heuristics are used to do both these tasks.
               Variable ordering is based on the topological order
               generated by the module manager. Based on conventional wisdom,
               we keep the "present" and "next" pairs together for each
               variable.
               The partitioning is conjunctive, with each conjunct
               representing the transition relation for an atom.

               Restrictions:
               Currently, the next operator is not
               supported. 
               ]

  SeeAlso     [optional]

  Author      [Sriram K. Rajamani]

  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]

  Revision    [$Id: sym.h,v 1.1.1.1 2001/09/22 20:42:57 luca Exp $]

******************************************************************************/

#ifndef _SYM
#define _SYM

/*---------------------------------------------------------------------------*/
/* Constant declarations                                                     */
/*---------------------------------------------------------------------------*/
#include "main.h"
#include "mdl.h"
#include "var.h"
#include "atm.h"
#include "img.h"
#include "mvf.h"

/*---------------------------------------------------------------------------*/
/* Type declarations                                                         */
/*---------------------------------------------------------------------------*/

/* these two are for region interface management */
typedef struct SymRegionStruct Sym_Region_t;
typedef struct SymRegionManagerStruct Sym_RegionManager_t;
typedef struct SymTransStruct Sym_Trans_t;
typedef struct SymInfoStruct  Sym_Info_t;

/*---------------------------------------------------------------------------*/
/* Structure declarations                                                    */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Variable declarations                                                     */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Macro declarations                                                        */
/*---------------------------------------------------------------------------*/


/**AutomaticStart*************************************************************/

/*---------------------------------------------------------------------------*/
/* Function prototypes                                                       */
/*---------------------------------------------------------------------------*/

EXTERN void Sym_ModulePerformBFS(Tcl_Interp *interp, Main_Manager_t *mainManager, Mdl_Module_t *module, array_t *invNameArray, array_t *typedExprArray);
EXTERN void Sym_DebugTracePrint(Sym_Info_t *symInfo, array_t *savedOnions, int step, mdd_t *notInv, array_t *eventIdArray, array_t *histDependIdArray, char *invName, char *moduleName);
EXTERN void Sym_ModuleBuildTransitionRelation(Sym_Info_t *symInfo, Mdl_Module_t *module);
EXTERN mdd_t * Sym_ModuleBuildInitialRegion(Sym_Info_t *symInfo, Mdl_Module_t *module);
EXTERN mdd_t * Sym_AtomBuildTransitionRelation(Sym_Info_t *symInfo, Atm_Atom_t *atom);
EXTERN mdd_t * Sym_AtomBuildInitialRegion(Sym_Info_t *symInfo, Atm_Atom_t *atom);
EXTERN mdd_t * Sym_AssignmentBuildMdd(Sym_Info_t *symInfo, Atm_Assign_t *assign, st_table *assignedVarTable);
EXTERN mdd_t * Sym_ExprBuildMdd(Sym_Info_t *symInfo, Atm_Expr_t *expr);
EXTERN int Sym_Init(Tcl_Interp *interp, Main_Manager_t *manager);
EXTERN int Sym_Reinit(Tcl_Interp *interp, Main_Manager_t *manager);
EXTERN int Sym_End(Tcl_Interp *interp, Main_Manager_t *manager);
EXTERN Tcl_HashTable * Sym_RegionManagerReadRegionTable(Sym_RegionManager_t *regionManager);
EXTERN unsigned long Sym_RegionManagerReadCounter(Sym_RegionManager_t *regionManager);
EXTERN void Sym_RegionManagerIncrementCounter(Sym_RegionManager_t *regionManager);
EXTERN Sym_Region_t * Sym_RegionAlloc(Mdl_Module_t *module, mdd_t *regionMdd);
EXTERN void Sym_RegionFree(Sym_Region_t *region);
EXTERN Sym_RegionManager_t * Sym_RegionManagerAlloc();
EXTERN void Sym_RegionManagerFree(Sym_RegionManager_t *regionManager);
EXTERN Sym_Info_t * Sym_RegionManagerReadSymInfo(Sym_RegionManager_t *regionManager, Mdl_Module_t *module);
EXTERN void Sym_RegionManagerAddModuleToSymInfo(Sym_RegionManager_t *regionManager, Mdl_Module_t *module, Sym_Info_t *symInfo);
EXTERN void Sym_RegionManagerDeleteModuleToSymInfo(Sym_RegionManager_t *regionManager, Mdl_Module_t *module);
EXTERN Sym_Info_t * Sym_SymInfoAlloc(Tcl_Interp *interp, Mdl_Module_t *module, mdd_manager *manager);
EXTERN void Sym_SymInfoFree(Sym_Info_t *symInfo);
EXTERN void Sym_MddPrintCubes(Sym_Info_t *symInfo, mdd_t *mdd, int level);
EXTERN void Sym_MddPrintCubesImplSpec(Sym_Info_t *implSymInfo, Sym_Info_t *specSymInfo, mdd_t *mdd, int level);
EXTERN void Sym_MddPrintStateForErrorTrace(Sym_Info_t *symInfo, mdd_t *mdd, char **stateString);
EXTERN void Sym_MddPrintRawCubes(Sym_Info_t *symInfo, mdd_t *mdd, int level);
EXTERN boolean Sym_ModuleMatchMddIds(Mdl_Module_t *module1, Mdl_Module_t *module2, Sym_Info_t *symInfo1, Sym_Info_t *symInfo2, array_t *idArray1, array_t *idArray2);
EXTERN mdd_t * Sym_SymInfoBuildFlatTrans(Sym_Info_t *syminfo);
EXTERN st_table * Sym_SymInfoReadVarToUnprimedId(Sym_Info_t *symInfo);
EXTERN st_table * Sym_SymInfoReadVarToPrimedId(Sym_Info_t *symInfo);
EXTERN array_t * Sym_SymInfoReadUnprimedIdArray(Sym_Info_t *symInfo);
EXTERN array_t * Sym_SymInfoReadPrimedIdArray(Sym_Info_t *symInfo);
EXTERN array_t * Sym_SymInfoReadQuantifyIdArray(Sym_Info_t *symInfo);
EXTERN Img_ImageInfo_t * Sym_SymInfoReadImgInfo(Sym_Info_t *symInfo);
EXTERN st_table * Sym_SymInfoReadIdToVar(Sym_Info_t *symInfo);
EXTERN void Sym_SymInfoSetImgInfo(Sym_Info_t *symInfo, Img_ImageInfo_t *imgInfo);
EXTERN array_t * Sym_SymInfoReadConjuncts(Sym_Info_t *symInfo);
EXTERN mdd_manager * Sym_SymInfoReadManager(Sym_Info_t *symInfo);
EXTERN mdd_t * Sym_SymInfoReadConjunctForAtom(Sym_Info_t *symInfo, Atm_Atom_t *atom);
EXTERN void Sym_SymInfoSetConjunctForAtom(Sym_Info_t *symInfo, Atm_Atom_t *atom, mdd_t *atomMdd);
EXTERN boolean Sym_SymInfoLookupPrimedVariableId(Sym_Info_t *symInfo, Var_Variable_t *var, int *id);
EXTERN boolean Sym_SymInfoLookupUnprimedVariableId(Sym_Info_t *symInfo, Var_Variable_t *var, int *id);
EXTERN mdd_t  * Sym_MddPickMinterm(Sym_Info_t *symInfo, mdd_t *mdd);
EXTERN mdd_t * Sym_AtomsComputePartialImage(Sym_Info_t *symInfo, array_t *atomArray, mdd_t *prevState, mdd_t *partialState);
EXTERN mdd_t * Sym_AtomsBuildPartialInitialRegion(Sym_Info_t *symInfo, array_t *atomArray, mdd_t *partialState);
EXTERN int Sym_StateInMdd(mdd_manager * mddManager,  mdd_t * mdd,  array_t * varIdArray,  array_t * valueArray);
EXTERN int Sym_StateInMddWithResidueMdd(mdd_manager * mddManager, mdd_t * mdd,
                                        array_t * varIdArray, array_t *
                                        valueArray,  mdd_t ** returnMdd);


/**AutomaticEnd***************************************************************/

#endif /* _ */
