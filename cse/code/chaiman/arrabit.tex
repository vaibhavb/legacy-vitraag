
\subsection{Arrays}\index{type!array}\index{array}
\label{sec-arrays}

\mocha\ also has array and
bitvector\index{type!bitvector} types.  Arrays are
essentially as in ordinary programming languages, except that
multidimensional arrays are not provided, and other minor limitations
are present.  Each array variable has to be controlled by the same
module, but different array elements can be controlled by different
atoms: hence, you can think of arrays as a bus of wires or signals,
not necessarily controlled jointly. 
The syntax for declaring an array type is: 

\begin{quote} 
  \ARRAY\ \indextype\ \OF\ \elementtype
\end{quote}

Type \indextype\ is the type of the array index, and can be
an enumeration type or a range type (perhaps the most common case).
Type \elementtype\ is the type of the array elements, and can be a
boolean, integer, natural, enumeration, range, or bitvector type.
An example of an array declaration is 

\begin{quote} \tt
  interface x : array (0..10) of bool
\end{quote}

Table~\ref{table-array-access-syntax} describes the constructs
to express dereferencing of arrays in the context of variable declarations in atoms
as well as in expressions and assignments.

You can declare that an atom controls the whole array {\tt x} by
writing {\tt controls x}.  If the atom controls only some elements of
{\tt x}, you can specify these simply by listing them, as in {\tt
controls x[0], x[2], x[4]}.  You can specify which elements are read
or awaited in a similar way. 
Note that the array elements that are controlled, read, or awaited
must be specified using constants or elements of enumeration types only: you cannot write {\tt controls
x[1 + 2]} or {\tt awaits x[a]} if {\tt a} does not denote an element of an enumeration type.
If an array is controlled by the module (i.e.\ if it is declared as
{\tt interface} or {\tt private} in the module), then all array
elements must be controlled by some atom of the module.

You can refer to array elements by writing the variable name followed
by a range expression in square brackets, as in {\tt x[4]} or {\tt x[z
+ 1]}.  In an expression, you can refer to an element of an array of
type \ARRAY\ \indextype\ \OF\ \elementtype\ whenever you can refer to
a variable of type \elementtype.

You can assign values to individual array elements by using
constants to specify them or use the forall assignment to all elements
of the array together.
Moreover, you must specify the array element being
updated using constants only: for example, you can write {\tt x'[3] :=
true}, but not {\tt x'[y] := true} or even {\tt x'[3+1] := true}.
Thus, there is no direct way to update entry {\tt a} of array {\tt
x}. But, indirectly the same effect can be achieved by using the
forall assignment statement as described below. 

The forall assignment is used to assign values simultaneously to all
array entries. An example of the forall assignment is 

\begin{quote} \tt
forall i x'[i] := if (i = a) then y else x[i] fi
\end{quote}

{\tt i} is the index variable that is bound by the forall
statement. The effect is to assign to entry {\tt i} the value of the
expression on the right side with the value of {\tt i} subsituted for {\tt
i}. Notice also that the above example is just another way of saying 

\begin{quote} \tt
x'[a] := y
\end{quote}

Note that forall assignments may only occur in
\command\ expressions as given in Table~\ref{table-command-syntax}.

Modulo arithmetic is used for indexing whenever the index type of an
array is a range type, e.g., if array {\tt x} has index type {\tt
(0..3)}, {\tt x[3+3]} refers to {\tt x[2]}. An array {\tt x} can be
indexed only by a variable of identically the same type as its index
type. For example, an array with index type {\tt (0..7)} cannot be
indexed with a var of type int, or type {\tt (0..5)}.

An atom can read or await parts of an array, but then no expression in
the atom can index the array by a variable. Similarly, if an atom
controls only part of the array it can only update array elements
specified by constants.

\begin{table}\boxed{\begin{tabbing}
\adeclare\ \gramdef\ \LSQBRAC\intconst\ $|$ \element\RSQBRAC \\[3ex]
\arefer\ \gramdef\ \LSQBRAC\numexpr\ $|$ \enumvar\ $|$ \element\RSQBRAC \\[3ex]
\aassign\ \gramdef\ \adeclare\
\end{tabbing}}
\caption{Array access syntax}
\label{table-array-access-syntax}
\end{table}

\subsection{Bitvectors}\index{type!bitvector}\index{bitvector}
\label{sec-bitvector}

\begin{table}\boxed{\begin{tabbing}
\bitexpr\ \gramdef\ \= \intconst\ $|$ \bitvar \\[1ex]
                    \> $|$ \LPARA \bitexpr \RPARA\ $|$ \MINUS \bitexpr\ \\[1ex]
                    \> $|$ $\bitexpr_1$ \PLUS\ $\bitexpr_2$ \\[1ex]
                    \> $|$ $\bitexpr_1$ \MINUS\ $\bitexpr_2$ \\[1ex]
                    \> $|$ \NOT \bitexpr \\[1ex]
                    \> $|$ $\bitexpr_1$ \binbool\ $\bitexpr_2$ \\[1ex]
                    \> $|$ \IF\ \boolexpr\ \= \THEN\ $\bitexpr_1$ \\[1ex]
                    \>\> \ELSE\ $\bitexpr_2$ \\[3ex]
\bitvar\ \gramdef\ \ident[\nextop][\arefer]
\end{tabbing}}
\caption{Bitvector expression syntax\index{expression!bitvector}}  
\label{table-bitexpr-syntax}
\end{table}

Bitvectors are essentially arrays of booleans, except that you can
perform arithmetic and logical operations on a bitvector as a whole,
and  as a consequence each bitvector variable has to be controlled
by a single atom. The index type of a bitvector is always a range
type. An example of a declaration is 

\begin{quote} \tt
interface x : bitvector 8
\end{quote}

Here, {\tt x} has eight elements indexed by the range type {\tt
(0..7)}. The rules for reading or awaiting parts of bitvector
variables are identical to those for arrays. It is not possible for
different atoms to control parts of the same array; the whole
bitvector has to be controlled by the same atom. The forall assignment
can be used with bitvectors also. 

The operations available for bitvectors are arithmetic operations of addition and subtraction
(modulo $2^k$ for length $k$ bitvectors), and bitwise logical
operations \AND, \OR, \NOT, \IMPLY, and \EQUIV.
Table~\ref{table-bitexpr-syntax} provides the syntax of \bitexpr\ expressions.
Two bitvectors can be added (similarly
for other operations) only if they have the same lengths. Constants
can also be used as an argument to these operations. In such
expressions, the constant is interpreted as a constant bitvector of
the length of the other argument. Let {\tt x}, {\tt y}, {\tt z} be bitvectors of
length three.

\begin{quote} \tt
z' := (x \& y) + 5
\end{quote}

The numeral 5 in the above expression will be interpreted as the
constant bitvector {\tt 101}.









