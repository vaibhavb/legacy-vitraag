% The Theory of Discrete Systems, Ch. 1

\documentclass[11pt]{report}
\usepackage{latexsym}
\usepackage{amstext}
\usepackage{amsbsy}
\usepackage{fullpage}
\usepackage{epic} 
\usepackage{eepic} 
\usepackage{luca} 
\usepackage{ds}

\begin{document} 

\chapter{Models for Discrete Systems} 

\section{Interface Modules}

We define {\em interface modules,} a model for discrete system
components that can communicate with their environment.
Interface modules model both the behavior of a system component, and
the interface between the component and its environment. 
The goal of interface modules is to support the following activities. 
%
\begin{itemize} 

\item {\bf Top-down design decomposition.} 
A design is decomposed into components that can be designed and
implemented separately. 
The component model is used to specify the task of each component; the
interface specification ensures that the components, once implemented,
can work together correctly. 

\item {\bf Compositional verification.} 
In order to verify a complete design, each component is studied with
the help of assumptions about its environment. 
The results for the single components are then combined into an
analysis for the complete system. 
The interface specifications constitute the assumptions about the
environment, while the component models describe each component. 

\item {\bf Component-based design.} 
In component-based design, designs are created by combining
pre-existing and application-specific components.
The models of the components and their interfaces help in selecting
and combining the components, and in checking that the component
interfaces are compatible one with the other. 

\end{itemize}
%
In the remainder of this course, interface modules will be simply
called {\em modules.} 


\subsection{Modules, informally} 

The state of a module is described by a set of {\em state
variables,} partitioned into sets of {\em input\/} and {\em output\/}
variables. 
The input variables represent inputs to the module, and their value
can be read, but not changed, by the module; the output variables
represent outputs of the module, and their value can be changed (and
read) by the module. 
The possible changes of output variables are described by an 
{\em output transition relation,} while the changes of input variables
that are legal for the module are described by an 
{\em input transition relation.} 
Hence, the output transition relation models the module's behavior,
and the input transition relation models design assumptions about the
inputs provided by the environment. 
Finally, a set of {\em initial outputs\/} specifies the initial
condition of the module, and a set of {\em initial inputs\/} specifies
the desired initial condition of the environment. 
Hence, a {\em module\/} differs radically in spirit from the model of
a physical system as found in usual physics or engineering courses.
A model for a physical system defines the behavior of the system under
{\em all\/} external behaviors: for example, the model of a linear
system such as an (ideal) amplifier defines the output signal in
response to any input signal. 
In other words, usual models of physical systems do not constrain
their set of possible inputs. 
In contrast, a module encodes both the possible behaviors of the 
component (via its initial outputs and output transition relation), 
and the {\em legal\/} input behaviors (via its initial inputs, and the
input transition relation).

The behavior of a module consists of an infinite sequence
of states starting from an initial state. 
Each successive state is generated by the module and by its
environment: 
the modules chooses the new values of the output 
variables according to the output transition relation, 
and the environment must choose the new values of the input variables
according to the input transition relation. 


\subsection{Modules, formally} 

\paragraph{Variables.}
In order to define formally modules, we consider a global
(infinite) set $\allvars$ of {\em typed variables,} from which the
variables of the modules will be drawn. 
Each variable $x \in \allvars$ has an associated {\em domain,} or set
of possible values, which we denote $\domain(x)$.  
In this course, we will assume that $\domain(x)$ is a finite set,
restricting our attention to finite-state systems. 
An important special case is the one in which all variables are 
{\em boolean,} that is, their domain is the two-element set 
$\set{\false,\true}$.

\paragraph{States.}
Given a finite set $\vars\subs\allvars$ of variables, 
a {\em state\/} $s$ over $\vars$ is a function that associates with each
variable $x \in \vars$ a value $s(x) \in \domain(x)$; we
denote by $\states[\vars]$ the set of all possible states over the
variables $\vars$. 
Note that, formally, the type of $s \in \states[\vars]$ is 
$\prod_{x\in\vars} (x \mapsto \domain(x))$. 
Given a state $s \in \states[\vars]$ and a subset $\avars \subs \vars$
of variables, we denote by $s[\avars] \in \states[\avars]$ the
restriction of $s$ to the variables in $\avars$: precisely,
$s[\avars]$ is defined by $s[\avars](x) = s(x)$ for all 
$x \in \avars$. 
For any two set $\vars,\avars$ of variables, and states 
$s \in \states[\vars]$ and $t \in \states[\avars]$, 
we write $s \simeq t$ if $s(x) = t(x)$ for all 
shared variables $x \in \vars \inters \avars$. 

\paragraph{State predicates.} 
We assume a logical language $\loglang$ in which assertions about the
values of the variables in $\allvars$ can be written.  
For example, if all variables are boolean, then $\loglang$ can be
taken to be predicate logic with the addition of the
quantifiers $\forall$ and $\exists$ over the booleans. 
We say that a formula $\phi\in\loglang$ is {\em over\/} a set $\vars$
of variables if it only involves variables of $\vars$; such a formula
is also called a {\em predicate\/} over $\vars$.
We denote by $\Preds[\vars]$ the set of all formulas over the set of
variable $\vars$.  
Given a formula $\phi$ over $\vars$ and a state 
$s \in \states[\vars]$, we write $s \sat \phi$ to denote the fact that
$\phi$ is true under the interpretation that assigns to every variable
$x \in \vars$ the value $s(x)$. 
In particular, a formula $\phi$ over $\vars$ defines the set of states 
$\semb{\phi}_\vars = \set{s \in \states[\vars] \mid s \sat \phi}$. 

\begin{examp}{}
Consider the set of boolean variables $\vars = \set{x,y,z}$.
The set $\states[\vars]$ consists of $2^3 = 8$ elements. 
If we take $\loglang$ to be propositional logic, then the formula
$x \und \no y$ is satisfied by the two states 
$(x=\true,y=\false,z=\false), (x=\true,y=\false,z=\true) \in \states[\vars]$. 
If we take $\loglang$ to be quantified boolean formulas, then 
the formula 
$
  \exists w \qdot (w \equiv x \und w \equiv \no y \und w \equiv z)
$
is satisfied by the two states 
$(x=\true,y=\false,z=\true), (x=\false,y=\true,z=\false) \in \states[\vars]$. 
\qed
\end{examp}

\paragraph{Transition predicates.} 
In order to be able to define {\em relations,} in addition to sets of
states, we introduce the following notation. 
For each state variable $x$, we introduce a new variable 
$\nx{x}$ (read: ``next $x$''), with $\domain(x) = \domain(\nx{x})$,
that denotes the value of the state variable $x$ in the successor state. 
Given a set $\vars \subs \allvars$ of variables, we let
$\nx{\vars} = \set{\nx{x} \mid x \in \vars}$ be the corresponding set
of next variables. 
We denote the converse of $\nx{}$ by $\pr{}$ (read: ``previous''):
precisely, we let $\pr{\nx{x}} = x$ for all variables $x$. 
Given a predicate $\phi$, we denote by $\nx{\phi}$ the result of
replacing every variable $x$ in $\phi$ with $\nx{x}$, and by
$\pr{\phi}$ the result of replacing every $\nx{x}$ in $\phi$ with
$x$; obviously, $\pr{\nx{\phi}} = \phi$. 

Intuitively, in a transition predicate the standard variables refer to
the current state, and the next variables refer to the successor state. 
Given a predicate $\rho$ over $\vars \union \nx{\avars}$, and states 
$s \in \states[\vars]$ and $t \in \states[\avars]$, we write 
$(s,t) \sat \rho$ to denote the fact that $\rho$ is true when 
every $x \in \vars$ has value $s(x)$, and every $\nx{y} \in
\nx{\avars}$ has value $t(y)$. 
A transition predicate $\rho \in \Preds[\vars,\ne\avars]$ defines a
relation
\[
  \semb{\rho}_{\vars,\nx{\avars}} 
  = \set{(s,t) \in \states[\vars] \times \states[\avars] \mid 
         (s,t) \sat \rho}. 
\]

\begin{examp}{}
Consider the set of boolean variables $\vars = \set{x,y}$. 
The transition predicate $(\nx{x} \equiv y) \und \no \nx{y}$ defines the
transition that copies the value of $y$ into $x$, and sets $y$ to
$\false$. \qed
\end{examp}


\paragraph{Modules.}
Modules are defined as follows. 

\begin{defi}{(module)}
A {\em module\/} (TM) $\mp = \tuple{\ivars_\mp, \ovars_\mp,
\rvars_\mp, \iinit_\mp, \oinit_\mp, \itrans_\mp, \otrans_\mp}$
consists of the following elements:
%
\begin{itemize}

\item A set $\ivars_\mp$ of {\em input variables,} and a set
$\ovars_\mp$ of {\em output variables.}
The two sets must be disjoint: 
$\ivars_\mp \inters \ovars_\mp = \emptyset$. 
We indicate by $\vars_\mp = \ivars_\mp \union \ovars_\mp$ the set of
all state variables of $\mp$. 

\item A set $\rvars_\mp$ of {\em reserved variables,} 
such that $\ivars_\mp \union \ovars_\mp \subs \rvars_\mp$. 
The set $\rvars_\mp$ contains variables that are reserved for use by
the module, and constitute the module {\em name space.} 

\item A predicate $\iinit_\mp \in \Preds[\ivars_\mp]$
defining the legal initial values for the input variables. 

\item A predicate $\oinit_\mp \in \Preds[\ovars_\mp]$
defining the initial values of the output variables. 

\item An {\em input transition predicate\/}
$\itrans_\mp \in \Preds[\vars_\mp \union \nx{\ivars_\mp}]$, 
such that for all $s \in \states[\vars_\mp]$, there is 
some $t \in \states[\ivars_\mp]$ such that $(s,t) \sat \itrans_\mp$. 
The predicate $\itrans_\mp$ specifies what are the legal value
changes for the input variables. 

\item An {\em output transition predicate\/}
$\otrans_\mp \in \Preds[\vars_\mp \union \nx{\ovars_\mp}]$, 
such that for all $s \in \states[\vars_\mp]$, there is 
some $t \in \states[\ovars_\mp]$ such that $(s,t) \sat \otrans_\mp$.
The predicate $\otrans_\mp$ specifies how the module can update the
values of the output variables. 
\qed

\end{itemize}
\end{defi}

\noindent
Associated with a module is a set of initial states, a transition
relation, and a language.  
The set of initial states consists of the states that correspond to
both possible initial values for the output variables, and legal
initial values for the input variables.
The transition relation consists of the state transitions that are
both possible for the output variables, and legal for the input
variables. 
The language of a module consists of all the possible infinite
sequences of states that satisfy the initial conditions and the
transition relations. 

\begin{defi}{(set of [initial] states, transition relation, trace, and language)}
Consider a module $\mp = \tuple{\ivars_\mp, \ovars_\mp, \rvars_\mp, 
\iinit_\mp, \oinit_\mp, \itrans_\mp, \otrans_\mp}$. 
%
\begin{itemize}

\item 
The set of {\em states\/} of $\mp$ is $S_\mp = \states[\vars_\mp]$. 

\item 
The set of {\em initial states\/} of $\mp$ is 
$\sinit_\mp = \set{s \in S_\mp \mid s \sat \iinit_\mp \und \oinit_\mp}$. 

\item 
The {\em transition relation\/} of $\mp$ is 
$\tr_\mp = \set{(s,t) \in S_\mp \times S_\mp \mid 
(s,t) \sat \itrans_\mp \und \otrans_\mp}$. 

\item 
A {\em path\/} of $\mp$ from $s \in S_\mp$ is an infinite sequence 
$s=s_0, s_1, s_2, \ldots$ of $S_\mp$ such that 
$(s_k,s_{k+1}) \in \tr_\mp$ for all $k > 0$. 

\item 
A {\em trace\/} of $\mp$ is a path $s_0, s_1, s_2, \ldots$ 
such that $s_0 \in \sinit_\mp$. 

\item
The {\em language\/} of $\mp$ is the set $\lang(\mp)$ consisting of
all traces of $\mp$. 
\qed
\end{itemize}
\end{defi}

The requirement on $\itrans_\mp$ and $\otrans_\mp$ ensures that every
state in $S_\mp$ has a successor that satisfies both the input and
output transition relations, ensuring that from every state, there is
a transition that is both possible for the module, and legal for the
environment. 
Note that if $\iinit_\mp \und \oinit_\mp$ is unsatisfiable, then
$\lang(\mp) = \emptyset$.

Transition modules are an example of {\em Moore\/} modules, in which
the next value of the output and internal variables can depend on the
current state, but not on the next value of the input variables. 
For instance, if the state variables of a module $\mp$ are $x$
(input) and $y$ (output), then in a transition from
$s \in S_\mp$ to $t \in S_\mp$ the next value $t(y)$ of $y$ can depend
on the old values $s(x)$ and $s(y)$, but not on the new value 
$t(x)$ of the input variable. 


\section{Closed and Universal Modules}  

\subsection{Closed modules}

A {\em closed\/} transition module is a module that has no input
variables: hence, a closed module cannot be influenced by its
environment.  

\begin{defi}{(closed transition module)}
A transition module $\mp = \tuple{\ivars_\mp, \ovars_\mp, \rvars_\mp, 
\iinit_\mp, \oinit_\mp, \itrans_\mp, \otrans_\mp}$ is {\em closed\/} if 
$\ivars_\mp = \emptyset$.  
\qed
\end{defi}

\noindent
Note that, if a module $\mp$ is closed, then the predicates 
$\iinit_\mp$ and $\itrans_\mp$ must be equivalent to $\true$. 
\ask{why?}
Hence, we can specify a closed module $\mp$ simply as
$\mp = \tuple{\ovars_\mp, \rvars_\mp, \init_\mp, \trans_\mp}$, where 
$\init_\mp=\oinit_\mp$ and $\trans_\mp=\otrans_\mp$. 

\paragraph{Closure of an open module.}
The {\em universal closure\/} of an open module consists in the closed
module obtained by considering an open module in its {\em most general
environment,} that allows any update of input variables consistent with
the environment transition of the module.

\begin{defi}{(closure)} 
Given an open module  $\mp = \tuple{\ivars_\mp, \ovars_\mp,
\rvars_\mp, \iinit_\mp, \oinit_\mp, \itrans_\mp, \otrans_\mp}$, its 
{\em closure\/} $\closure(\mp)$ is the module defined by 
$\closure(\mp) = \tuple{\ivars_\mp \union \ovars_\mp, \rvars_\mp, 
\iinit_\mp \und \oinit_\mp, \itrans_\mp \und \otrans_\mp}$. 
\qed
\end{defi}

\subsection{Universal modules} 

A module is universal if it does not make any assumption about the
inptu behavior. 

\begin{defi}{(universal module)}
A module  $\mp = \tuple{\ivars_\mp, \ovars_\mp,
\rvars_\mp, \iinit_\mp, \oinit_\mp, \itrans_\mp, \otrans_\mp}$ is 
{\em universal\/} if $\iinit_\mp = \true$ and $\itrans_\mp = \true$. 
\qed
\end{defi}


\section{Bibliographic Notes}

The description of both module behavior and environment assumptions 
Interface modules describe both the module behavior and the
environment assumptions. 
In this respect, interface modules are related to {\em trace theory\/}
\cite{DillThesis}, as well as to the models for interface
specification and compatibility checking of 
\cite{luca-ia-01,luca-it-01}. 
Indeed, interface modules are a variable-based version of
the {\em stateful assume/guarantee interfaces\/} of
\cite{luca-it-01}. 
Universal modules do not specify environment assumptions, and are
similar to the classical models used in model-checking
\cite{SMV96,VIS96,RM96journal}.

In the definition of modules, we have followed the classical
approach of describing a system by specifying its set of state
variables, and by defining its state space and state transitions
explicitly \cite{Unity}.
Another style of modeling takes as primary element the transitions,
often called {\em actions,} rather than the states.
Among the modeling languages that are action-based, we recall 
{\em process algebras\/} \cite{MilnerCCS,Hoare85,Hennessy88,Milner90}
and {\em I/O Automata\/} \cite{LT87,Lynch96}.
The duality in the modeling of component behavior and input behavior

Interface modules are an instance of {\em Moore\/} modules.  
In many cases it is useful to allow more general dependencies between
the updated values of the variables: for example, in the modeling of
synchronous hardware, these dependencies can be used to encode
{\em Mealy\/} machines.
Models for synchronous systems that capture increasingly general
communication patterns, including Mealy machines, have been presented
in \cite{RM96journal,synchronous_control_00,synchronous_control_01}. 

\bibliographystyle{alpha}
\bibliography{luca}

\end{document}
