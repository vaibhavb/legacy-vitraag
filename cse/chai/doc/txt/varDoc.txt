The var package

Data structures and routines to manipulate variables and
variable types

Freddy Mang, Shaz Qadeer, Sriram Rajamani

**********************************************************************

Var_End()                      Ends the var package.

Var_EnumElementAlloc()         Allocates a new symbolic constant for an
                               enumerated data                       type.

Var_EnumElementFree()          Frees an eumerative type constant.

Var_EnumElementObtainIndex()   Returns the index of the enumerated element of
                               a                       symbolic variable.

Var_EnumElementReadName()      Returns the name of an element.

Var_EnumElementReadType()      Returns a pointer to the type of an given
                               element.

Var_Init()                     Initializes the var package.

Var_RangeTypeReadFromRange()   required

Var_Reinit()                   Reinitializes the var package.

Var_TypeConvertToString()      It converts a variable type to a string.

Var_TypeIsArray()              Checks if a type is an array type

Var_TypeIsBV()                 Checks if a type is a bitvector or a
                               bitvector_n.

Var_TypeIsBitvectorN()         Checks if a type is a bitvector_n.

Var_TypeIsBitvector()          Checks if a type is a bitvector or a
                               bitvector_n.

Var_TypeIsBoolean()            Checks if a type is a boolean.

Var_TypeIsCompatibleWithNumConst()
                               Check if the type is compatible with number
                               constants.

Var_TypeIsEnum()               Checks if a type is an enum type

Var_TypeIsEvent()              Checks if a type is an event type

Var_TypeIsFinite()             Checks if a type is finite.

Var_TypeIsRange()              Checks if a type is an range type

Var_TypeIsTimer()              Checks if a type is an timer type

Var_TypeManagerAddEnumElement()
                               For enumerative type, add a new type element.

Var_TypeManagerAddType()       Add a variable type into the type manager.

Var_TypeManagerFree()          Free the type mananager

Var_TypeManagerInit()          Init the type manager

Var_TypeManagerObtainType()    Returns a pointer to the datatype struct.

Var_TypeManagerReadEnumElementFromName()
                               Returns a pointer to the element given a name.

Var_TypeManagerReadTypeFromName()
                               Returns a pointer to the datatype struct given
                               the name.

Var_TypeManagerReadVarTypeTable()
                               Returns the type table from the type manager

Var_TypesAreCompatible()       Checks if two types are compatible.

Var_VarNewTimerTypeAlloc()     Allocates a new variable type for a timer
                               variable.

Var_VarTimeIncrementTypeAlloc()
                               Allocates a variable type for the time
                               increment variable.

Var_VarTypeArrayAlloc()        Allocates an array type.

Var_VarTypeArrayOrBitvectorReadSize()
                               Returns the size of the domain of the variable
                               type.

Var_VarTypeBasicAlloc()        Allocates a new variable type.

Var_VarTypeBitvectorAlloc()    Allocates a bitvector type.

Var_VarTypeBitvectorNAlloc()   Allocates a bitvectorN type.

Var_VarTypeDup()               Makes a copy of a variable type.

Var_VarTypeEnumeratedAlloc()   Allocates an enumerated type.

Var_VarTypeFree()              Frees a variable type

Var_VarTypeRangeAlloc()        Allocates a range type.

Var_VarTypeReadDataType()      Returns the data type of a varable type.

Var_VarTypeReadDomainSize()    Returns the size of the domain of the variable
                               type.

Var_VarTypeReadEntryType()     Returns the entry type of an array data type.

Var_VarTypeReadIndexFromSymbolicValue()
                               Returns the integer index associated with a
                               symbolic constant                for an
                               enumerated data type.

Var_VarTypeReadIndexToValue()  Checks if a variable is an external variable.

Var_VarTypeReadIndexType()     Returns the index type of an array data type.

Var_VarTypeReadName()          Return the name of the variable type.

Var_VarTypeReadSymbolicValueFromIndex()
                               Returns the name of the symbolic constant
                               associated with an                integer index
                               for an enumerated data type.

Var_VariableAddToAwaitByAtomList()
                               Add an atom to the awaitByAtomList.

Var_VariableAddToReadByAtomList()
                               Add an atom to the readByAtomList.

Var_VariableAlloc()            Allocates a new variable.

Var_VariableChangeName()       Changes the name of a variable.

Var_VariableFree()             Frees a variable.

Var_VariableIsBoolean()        Checks if the variable is a boolean variable.

Var_VariableIsDummy()          Checks if a variable is a dummy variable.

Var_VariableIsEvent()          Checks if a variable is an event variable.

Var_VariableIsExternal()       Checks if a variable is an external variable.

Var_VariableIsHistoryDependent()
                               Checks if the variable is history dependent.

Var_VariableIsHistoryFree()    Checks if the variable is history free.

Var_VariableIsInterface()      Checks if a variable is an interface variable.

Var_VariableIsPrivate()        Checks if a variable is a private variable.

Var_VariableObtainEnumElementFromIndex()
                               Returns the enumerated element of a symbolic
                               variable                       from its index.

Var_VariableReadAwaitList()    Return a pointer to the list of atoms awaiting
                               this var.

Var_VariableReadControlAtom()  Return a pointer to the atom controlling this
                               var.

Var_VariableReadDataType()     Returns the data type of a variable.

Var_VariableReadIndexToValue() Checks if a variable is an external variable.

Var_VariableReadModule()       Returns the module to which a variable belongs.

Var_VariableReadName()         Returns the name of a variable.

Var_VariableReadPEID()         returns an integer indicating the class of the
                               variable.

Var_VariableReadReadList()     Return a pointer to the list of atoms reading
                               this var.

Var_VariableReadTypeName()     Returns a string containing the type name of a
                               variable.

Var_VariableReadType()         Returns a pointer to the type of a variable.

Var_VariableSetControlAtom()   Set a pointer to the atom which controls this
                               atom.

Var_VariableSetPEID()          set the class type of the variable.

Var_VariableTypeReadNumVals()  Returns the number of values a variable of this
                               type can take

Var_VariableTypeSetNumVals()   Modifies the number of values a variable of
                               this type can take

**********************************************************************

optional

int
Var_End(
  Tcl_Interp *      interp,
  Main_Manager_t *  manager
)
  Ends the var package.

  Side Effects: None

Var_EnumElement_t *
Var_EnumElementAlloc(
  char *            name,
  Var_Type_t *      dataType
)
  Allocates a new symbolic constant for an enumerated data type. It makes a
  copy of name. Hence, it is the user's responsibility to free his copy.

  Side Effects: None

void
Var_EnumElementFree(
  Var_EnumElement_t typeconst
)
  It frees an enumerative constant.

  Side Effects: required

int
Var_EnumElementObtainIndex(
  Var_EnumElement_t element
)
  The function returns the index of the enumerated element of a symbolic
  variable, if successful. Otherwise, it returns -1.

  Side Effects: None

char*
Var_EnumElementReadName(
  Var_EnumElement_t element
)
  This function returns a pointer to the name of the enumerative type
  constant. User should not free or modify the string.

  Side Effects: required

Var_Type_t*
Var_EnumElementReadType(
  Var_EnumElement_t element
)
  Should not free the pointer.

  Side Effects: required

int
Var_Init(
  Tcl_Interp *      interp,
  Main_Manager_t *  manager
)
  Initializes the var package.

  Side Effects: The command, show_types is registered.

Var_Type_t *
Var_RangeTypeReadFromRange(
  Var_TypeManager_t typeManager,
  int               num
)
  optional

  Side Effects: required

int
Var_Reinit(
  Tcl_Interp *      interp,
  Main_Manager_t *  manager
)
  Reinitializes the var package.

  Side Effects: None

char *
Var_TypeConvertToString(
  Var_Type_t *      type
)
  This routine prints a type (without name) to a string. For example, a range
  type is printed as "(0..n)", and a bitvector type is printed as "bitvector
  n", where n in both cases refer to the size of the data type. This routine
  should not be called when the type is one of the built-in type, namely,
  event, bool, int and nat.

  Side Effects: It returns a string. User should free the string after use.

boolean
Var_TypeIsArray(
  Var_Type_t *      type
)
  This function returns true if the type is an array type.

  Side Effects: required

boolean
Var_TypeIsBV(
  Var_Type_t *      type
)
  This function returns true if the type is a bitvector type.

  Side Effects: required

boolean
Var_TypeIsBitvectorN(
  Var_Type_t *      type
)
  This function returns true if the type is a bitvector type.

  Side Effects: required

boolean
Var_TypeIsBitvector(
  Var_Type_t *      type
)
  This function returns true if the type is a bitvector type.

  Side Effects: required

boolean
Var_TypeIsBoolean(
  Var_Type_t *      type
)
  This function returns true if the type is a boolean type.

  Side Effects: required

boolean
Var_TypeIsCompatibleWithNumConst(
  Var_Type_t *      type
)
  This function checks if the give type is compatible with number constants.
  This is used in type checking, where, for instance, a variable of type Range
  can add to a number constant. Other compatible types are Integer, Natural,
  Bitvector and NumConst.

  Side Effects: required

boolean
Var_TypeIsEnum(
  Var_Type_t *      type
)
  This function returns true if the type is an enum type.

  Side Effects: required

boolean
Var_TypeIsEvent(
  Var_Type_t *      type
)
  This function returns true if the type is an event type.

  Side Effects: required

boolean
Var_TypeIsFinite(
  Var_Type_t *      type
)
  This function returns true if the type is a finite type.

  Side Effects: required

boolean
Var_TypeIsRange(
  Var_Type_t *      type
)
  This function returns true if the type is an range type.

  Side Effects: required

boolean
Var_TypeIsTimer(
  Var_Type_t *      type
)
  This function returns true if the type is a timer type.

  Side Effects: required

boolean
Var_TypeManagerAddEnumElement(
  Var_TypeManager_t typeManager,
  Var_EnumElement_t element
)
  If successful, return a pointer to the new element.

  Side Effects: required

Var_Type_t *
Var_TypeManagerAddType(
  Var_TypeManager_t typeManager,
  Var_Type_t*       type
)
  This function adds a type into the type manager. First it looks up if the
  type is already defined. If so, return the pointer to the defined one, and
  frees the given one. If not, add the type into the type manager.

  Side Effects: required

void
Var_TypeManagerFree(
  Var_TypeManager_t typemanager
)
  This frees all the variable types first, then the type table and the enum
  constant table, as well as the typemanager itself.

  Side Effects: required

Var_TypeManager_t*
Var_TypeManagerInit(

)
  This function initializes the type manager. The variable type table and the
  enumerative elements table are initialized. Built in variable types, namely
  bool, int, nat and event are created and hashed in the variable type table.
  It returns the type manager.

  Side Effects: required

Var_Type_t*
Var_TypeManagerObtainType(
  Var_TypeManager_t typeManager,
  Var_Type_t*       type
)
  Should not free the pointer.

  Side Effects: required

Var_EnumElement_t*
Var_TypeManagerReadEnumElementFromName(
  Var_TypeManager_t typeManager,
  char *            name
)
  for enumerative type, given a name and the typemanager, this function first
  lookup the type_element_table, and return a pointer the the element if
  found. Returns NIL(Var_EnumElement_t) if the element is not found.

  Side Effects: required

Var_Type_t*
Var_TypeManagerReadTypeFromName(
  Var_TypeManager_t typeManager,
  char*             name
)
  Should not free the pointer.

  Side Effects: required

st_table *
Var_TypeManagerReadVarTypeTable(
  Var_TypeManager_t typeManager
)
  This functions returns the var type table from the type manager. Users
  should not free the table.

  Side Effects: required

boolean
Var_TypesAreCompatible(
  Var_Type_t *      type1,
  Var_Type_t *      type2
)
  This function returns true if the given two types are compatible. It checks
  if any of the two type is a num_const. If so, check if the other one is
  compatible with a num_const. Otherwise, check if the two types are equal.

  Side Effects: required

Var_Type_t *
Var_VarNewTimerTypeAlloc(

)
  Allocates a new variable type for a timer variable. Returns a pointer to the
  variable if success. Otherwise, NIL(Var_Type_t) is returned.


Var_Type_t *
Var_VarTimeIncrementTypeAlloc(
  long              maxIncrement
)
  Allocates a variable type for the time increment variable.


Var_Type_t *
Var_VarTypeArrayAlloc(
  char *            name,
  Var_Type_t *      indexType,
  Var_Type_t *      entryType
)
  Allocates a new array type. The name string is copied for internal use. The
  user is responsible for freeing the original string. Returns a pointer to
  the type if success. Otherwise, NIL(Var_Type_t) is returned.


int
Var_VarTypeArrayOrBitvectorReadSize(
  Var_Type_t*       type
)
  The function returns the size of the domain of a variable type for
  enumerated and range data types. For other variable types it returns -1.

  Side Effects: None

Var_Type_t *
Var_VarTypeBasicAlloc(
  char *            name,
  Var_DataType      datatype
)
  Allocates a new variable type. The name string is copied for internal use.
  The user is responsible for freeing the original string. Returns a pointer
  to the variable if success. Otherwise, NIL(Var_Type_t) is returned.


Var_Type_t *
Var_VarTypeBitvectorAlloc(
  char *            name,
  int               size
)
  Allocates a new bitvector type. The name string is copied for internal use.
  The user is responsible for freeing the original string. Returns a pointer
  to the type if success. Otherwise, NIL(Var_Type_t) is returned.


Var_Type_t *
Var_VarTypeBitvectorNAlloc(
  char *            name,
  int               size
)
  Allocates a new bitvector type. The name string is copied for internal use.
  The user is responsible for freeing the original string. Returns a pointer
  to the type if success. Otherwise, NIL(Var_Type_t) is returned.


Var_Type_t *
Var_VarTypeDup(
  Var_Type_t *      type,
  char *            name
)
  Makes a copy of a variable type, which is then assigned a new name.
  Typically, the new type will be put into the typetable afterwards. The name
  can be NIL(char).


Var_Type_t *
Var_VarTypeEnumeratedAlloc(
  char *            name,
  array_t *         indexToValue,
  st_table *        valueToIndex
)
  Allocates a new enumerated type. The name string is copied for internal use.
  The user is responsible for freeing the original string. Returns a pointer
  to the type if success. Otherwise, NIL(Var_Type_t) is returned.


void
Var_VarTypeFree(
  Var_Type_t *      type
)
  It frees a variable type. For enumerative types, it is the users
  responsbility to free the enum constants before freeing this type.


Var_Type_t *
Var_VarTypeRangeAlloc(
  char *            name,
  int               range
)
  Allocates a new rnage type. The name string is copied for internal use. The
  user is responsible for freeing the original string. Returns a pointer to
  the type if success. Otherwise, NIL(Var_Type_t) is returned.


Var_DataType
Var_VarTypeReadDataType(
  Var_Type_t*       type
)
  The function returns the data type of a varable type.

  Side Effects: None

int
Var_VarTypeReadDomainSize(
  Var_Type_t*       type
)
  The function returns the size of the domain of a variable type for
  enumerated and range data types. For other variable types it returns -1.

  Side Effects: None

Var_Type_t *
Var_VarTypeReadEntryType(
  Var_Type_t *      varType
)
  The function returns the entry type of an array data type.

  Side Effects: None

int
Var_VarTypeReadIndexFromSymbolicValue(
  Var_Type_t *      type,
  Var_EnumElement_t symValue
)
  The function returns the integer index associated with a symbolic constant
  for and enumerated data type. If the data type is not enumerated or the
  symbolic name is not valid, the routine returns -1.

  Side Effects: None

array_t *
Var_VarTypeReadIndexToValue(
  Var_Type_t*       varType
)
  The function returns TRUE if the variable is an external variable, otherwise
  it returns FALSE.

  Side Effects: None

Var_Type_t *
Var_VarTypeReadIndexType(
  Var_Type_t *      varType
)
  The function returns the index type of an array data type.

  Side Effects: None

char*
Var_VarTypeReadName(
  Var_Type_t*       type
)
  The user should not free the returned string.

  Side Effects: required

Var_EnumElement_t *
Var_VarTypeReadSymbolicValueFromIndex(
  Var_Type_t *      type,
  int               i
)
  The function returns the name of the symbolic constant associated with an
  integer index for an enumerated data type. For other types, it returns
  NIL(Var_EnumElement_t).

  Side Effects: None

void
Var_VariableAddToAwaitByAtomList(
  Var_Variable_t*   var,
  VarAtomGeneric    atom
)
  Add an atom to the awaitByAtomList. Note since atm package is not included
  in this package, user should cast the pointer to the atom to VarAtomGeneric
  before calling this function.

  Side Effects: required

void
Var_VariableAddToReadByAtomList(
  Var_Variable_t*   var,
  VarAtomGeneric    atom
)
  Add an atom to the readByAtomList. Note since atm package is not included in
  this package, user should cast the pointer to the atom to VarAtomGeneric
  before calling this function.

  Side Effects: required

Var_Variable_t *
Var_VariableAlloc(
  VarModuleGeneric  module,
  char *            name,
  Var_Type_t *      type
)
  Allocates a new variable. The arguments of this function are a pointer to
  the module to which a new variable belongs, name of the variable, and a
  pointer to the type of the variable. The name string is copied for internal
  use. The user is responsible for freeing the original string. Returns a
  pointer to the variable if success. Otherwise, NIL(Var_Variable_t) is
  returned.


void
Var_VariableChangeName(
  Var_Variable_t *  var,
  char *            name
)
  Changes the name of a variable.

  Side Effects: The original name is freed. A copy of the new name is stored.

int
Var_VariableFree(
  Var_Variable_t *  var
)
  It frees a variable structure.


boolean
Var_VariableIsBoolean(
  Var_Variable_t *  var
)
  Returns TRUE if the variable is boolean, FALSE otherwise.

  Side Effects: required

boolean
Var_VariableIsDummy(
  Var_Variable_t*   var
)
  The function returns TRUE if the variable is an external variable, otherwise
  it returns FALSE.

  Side Effects: None

boolean
Var_VariableIsEvent(
  Var_Variable_t*   var
)
  The function returns TRUE if the variable is an event variable, otherwise it
  returns FALSE. There are three categories in which the set of variables is
  partitioned - event variables, history free variables and history dependent
  variables.

  Side Effects: None

boolean
Var_VariableIsExternal(
  Var_Variable_t*   var
)
  The function returns TRUE if the variable is an external variable, otherwise
  it returns FALSE.

  Side Effects: None

boolean
Var_VariableIsHistoryDependent(
  Var_Variable_t *  var
)
  The function returns TRUE if the variable is history dependent, otherwise it
  returns FALSE. There are three categories in which the set of variables is
  partitioned - event variables, history free variables and history dependent
  variables.

  Side Effects: None

boolean
Var_VariableIsHistoryFree(
  Var_Variable_t*   var
)
  The function returns TRUE if the variable is history free, otherwise it
  returns FALSE. There are three categories in which the set of variables is
  partitioned - event variables, history free variables and history dependent
  variables.

  Side Effects: None

boolean
Var_VariableIsInterface(
  Var_Variable_t*   var
)
  The function returns TRUE if the variable is an interface variable,
  otherwise it returns FALSE.

  Side Effects: None

boolean
Var_VariableIsPrivate(
  Var_Variable_t*   var
)
  The function returns TRUE if the variable is an private variable, otherwise
  it returns FALSE.

  Side Effects: None

Var_EnumElement_t *
Var_VariableObtainEnumElementFromIndex(
  Var_Variable_t *  var,
  int               index
)
  The function returns the enumerated element of a symbolic variable from its
  index if the index is within the the domain size of the variable. If the
  variable is not symbolic or the index is not within the domain size
  NIL(Var_EnumElemant_t) is returned.

  Side Effects: None

lsList
Var_VariableReadAwaitList(
  Var_Variable_t*   var
)
  It returns the pointer pointing to the list of atoms awaiting the variable.
  User should not free this pointer.

  Side Effects: required

VarAtomGeneric
Var_VariableReadControlAtom(
  Var_Variable_t*   var
)
  This function returns the pointer to the atom that controls this variable.
  If the atom is an external variable, the pointer is NIL.

  Side Effects: required

Var_DataType
Var_VariableReadDataType(
  Var_Variable_t*   var
)
  The function returns the data type of the variable.

  Side Effects: None

array_t *
Var_VariableReadIndexToValue(
  Var_Variable_t*   var
)
  The function returns TRUE if the variable is an external variable, otherwise
  it returns FALSE.

  Side Effects: None

VarModuleGeneric
Var_VariableReadModule(
  Var_Variable_t *  var
)
  It returns a pointer to the module to which this variable belongs. Since the
  the module structure is defined in the mdl package, which is "higher" than
  the var package, the pointer to the module is casted to VarModuleGeneric.
  User should cast the pointer to Mdl_Module_t* when this function is used.

  Side Effects: User should not free the module.

char *
Var_VariableReadName(
  Var_Variable_t *  var
)
  It reads the name of a variable. User should not free the name.

  Side Effects: None

int
Var_VariableReadPEID(
  Var_Variable_t*   var
)
  returns 0 if private, 1 if external, 2 if interface, and 3 if it is a dummy
  variable.

  Side Effects: required

lsList
Var_VariableReadReadList(
  Var_Variable_t*   var
)
  It returns the pointer pointing to the list of atoms reading the variable.
  User should not free this pointer.

  Side Effects: required

char*
Var_VariableReadTypeName(
  Var_Variable_t *  var
)
  Returns a string containing the type name of a variable.

  Side Effects: The string should not be freed.

Var_Type_t*
Var_VariableReadType(
  Var_Variable_t *  var
)
  Returns a pointer to the type of a variable.


void
Var_VariableSetControlAtom(
  Var_Variable_t*   var,
  VarAtomGeneric    atm
)
  The pointer, ctrlByAtom, is pointing to the atom that controls this atom.
  This routine set this pointer to the appropriate atom.

  Side Effects: required

void
Var_VariableSetPEID(
  Var_Variable_t*   var,
  int               peid
)
  set the class(private/external/interface/dummy) of the variable.

  Side Effects: required

int
Var_VariableTypeReadNumVals(
  Var_Type_t*       type
)
  The function returns the number of values a variable of this type can take -
  this makes sensse only for timer and time increment data types

  Side Effects: None

int
Var_VariableTypeSetNumVals(
  Var_Type_t*       type,
  int               numValues
)
  The function modifies the number of values a variable of this type can take
  - this makes sensse only for timer and range data types

  Side Effects: None

