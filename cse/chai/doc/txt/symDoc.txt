The sym package

building symbolic transition relation for a module

Sriram K. Rajamani

**********************************************************************

Sym_AssignmentBuildMdd()       build MDD for an assignment

Sym_AtomBuildInitialRegion()   build initial region for an atom

Sym_AtomBuildTransitionRelation()
                               build transition relation for an atom

Sym_AtomsBuildPartialInitialRegion()
                               build mdd for partial initial region

Sym_AtomsComputePartialImage() Compute partial image with respect to a set of
                               atoms

Sym_DebugTracePrint()          print debug trace for an invariant

Sym_End()                      Termination function for sym package

Sym_ExprBuildMdd()             build MDD for an expression

Sym_Init()                     Initilization function for sym package

Sym_MddPickMinterm()           utility to pick a minterm form a MDD

Sym_MddPrintCubesImplSpec()    Utility to dump mdds

Sym_MddPrintCubes()            Utility to dump mdds

Sym_MddPrintRawCubes()         Utility to dump mdds - in terms of raw mdd ids

Sym_MddPrintStateForErrorTrace()
                               Utility to generate a state string for Tcl
                               error                       trace display

Sym_ModuleBuildInitialRegion() build mdd for initial region of module

Sym_ModuleBuildTransitionRelation()
                               build symbolic transtion relation for a module

Sym_ModuleMatchMddIds()        match mdd ids of two modules

Sym_ModulePerformBFS()         do invariant checking

Sym_RegionAlloc()              Allocate a region struct

Sym_RegionFree()               required

Sym_RegionManagerAddModuleToSymInfo()
                               Add a module and symInfo pair to the
                               moduleToSymInfo table

Sym_RegionManagerAlloc()       Allocate a region manager

Sym_RegionManagerDeleteModuleToSymInfo()
                               Delete a module-syminfo pair from
                               moduleToSymInfo table

Sym_RegionManagerFree()        required

Sym_RegionManagerIncrementCounter()
                               Increment region manager's region counter

Sym_RegionManagerReadCounter() Read region manager's region counter

Sym_RegionManagerReadRegionTable()
                               Read region manager's region table

Sym_RegionManagerReadSymInfo() Find the symInfo for the given module

Sym_Reinit()                   Re-initialization function for sym package

Sym_StateInMddWithResidueMdd() Check if a state is in the mdd.

Sym_StateInMdd()               Check if a state is in the mdd.

Sym_SymInfoAlloc()             Allocate and return a symInfo struct

Sym_SymInfoBuildFlatTrans()    Utility to build a flat transition relation

Sym_SymInfoFree()              Utility to free symInfo

Sym_SymInfoLookupPrimedVariableId()
                               lookup primed mdd id for a variable

Sym_SymInfoLookupUnprimedVariableId()
                               lookup unprimed mdd id for a variable

Sym_SymInfoReadConjunctForAtom()
                               read the conjunct  (transtion relation) for the
                               given atom

Sym_SymInfoReadConjuncts()     read the conjuncts from symInfo

Sym_SymInfoReadIdToVar()       read the idToVar table from symInfo

Sym_SymInfoReadImgInfo()       read the image info from symInfo

Sym_SymInfoReadManager()       read the mdd manager from symInfo

Sym_SymInfoReadPrimedIdArray() read the primedIdArray array

Sym_SymInfoReadQuantifyIdArray()
                               read the quantifyIdArray array

Sym_SymInfoReadUnprimedIdArray()
                               read the unprimedIdArray array

Sym_SymInfoReadVarToPrimedId() read the varToPrimedId st_table

Sym_SymInfoReadVarToUnprimedId()
                               read the varToUnprimedId st_table

Sym_SymInfoSetConjunctForAtom()
                               set the conjunct  (transtion relation) for the
                               given atom

Sym_SymInfoSetImgInfo()        read the image info from symInfo

**********************************************************************

This package contains routines to build the symbolic transition
relation for a module. The task of building the transition
relation has two main components:                1. Selecting a good variable
ordering for the BDD package.                2. Parititioning the transition
relation                Currently, simple heuristics are used to do both
these tasks.                Variable ordering is based on the topological
order                generated by the module manager. Based on conventional
wisdom,                we keep the "present" and "next" pairs together for
each                variable.                The partitioning is conjunctive,
with each conjunct                representing the transition relation for an
atom.                 Restrictions:                Currently, the next
operator is not                supported.

mdd_t *
Sym_AssignmentBuildMdd(
  Sym_Info_t *      symInfo,
  Atm_Assign_t *    assign,
  st_table *        assignedVarTable
)
  Given an assignment, build an MDD for the assignment

  Side Effects: The variables that are assigned to, are added to the
  assignedVarTable that is passed in

mdd_t *
Sym_AtomBuildInitialRegion(
  Sym_Info_t *      symInfo,
  Atm_Atom_t *      atom
)
  build intial region for atom

  Side Effects: none

mdd_t *
Sym_AtomBuildTransitionRelation(
  Sym_Info_t *      symInfo,
  Atm_Atom_t *      atom
)
  build transition relation for an atom

  Side Effects: none

mdd_t *
Sym_AtomsBuildPartialInitialRegion(
  Sym_Info_t *      symInfo,
  array_t *         atomArray,
  mdd_t *           partialState
)
  build mdd for partial initial region

  Side Effects: none

mdd_t *
Sym_AtomsComputePartialImage(
  Sym_Info_t *      symInfo,
  array_t *         atomArray,
  mdd_t *           prevState,
  mdd_t *           partialState
)
  Compute partial image with respect to a set of atoms

  Side Effects: none

void
Sym_DebugTracePrint(
  Sym_Info_t *      symInfo,
  array_t *         savedOnions,
  int               step,
  mdd_t *           notInv,
  array_t *         eventIdArray,
  array_t *         histDependIdArra
  char *            invName,
  char *            moduleName
)
  Given an array of MDDs (representing the onion ring), the step at which the
  error occured, the negation of the invariant that got violated, arrays of
  event and history free ids of the module, name of the invariant and module,
  this function prints the debug trace. It starts with the onion ring at the
  specified step and intersects it with the negation of the invariant. Then it
  successivey does pre-image computations and finds a path to an initial
  state. Then it reverses the path and and prints an error trace.

  Side Effects: none

int
Sym_End(
  Tcl_Interp *      interp,
  Main_Manager_t *  manager
)
  Currently this function does nothing. During a subsequent cleanup this
  should be made to free all memeory allocated by sym

  Side Effects: none

mdd_t *
Sym_ExprBuildMdd(
  Sym_Info_t *      symInfo,
  Atm_Expr_t *      expr
)
  This routined builds an MDD for an expression. Note that the expression
  *must* evaluate to a boolean value in order to be able to build an MDD.
  Otherwise an error message is printed, and the routine aborts

  Side Effects: none

int
Sym_Init(
  Tcl_Interp *      interp,
  Main_Manager_t *  manager
)
  This function is called when Mocha comes up and does the following: 1.
  Create hooks to sym package's functions for the supported commands 2.
  Allocate memory for SymRegionManager and deposit it in the main manager

  Side Effects: none

mdd_t  *
Sym_MddPickMinterm(
  Sym_Info_t *      symInfo,
  mdd_t *           mdd
)
  utility to pick a minterm form a MDD

  Side Effects: none

void
Sym_MddPrintCubesImplSpec(
  Sym_Info_t *      implSymInfo,
  Sym_Info_t *      specSymInfo,
  mdd_t *           mdd,
  int               level
)
  Dump the given MDD as a sum of cubes. Using symInfo, the MDD ids are
  translated to variable names in the reactive module description

  Side Effects: none

void
Sym_MddPrintCubes(
  Sym_Info_t *      symInfo,
  mdd_t *           mdd,
  int               level
)
  Dump the given MDD as a sum of cubes. Using symInfo, the MDD ids are
  translated to variable names in the reactive module description

  Side Effects: none

void
Sym_MddPrintRawCubes(
  Sym_Info_t *      symInfo,
  mdd_t *           mdd,
  int               level
)
  Utility to dump mdds - in terms of raw mdd ids

  Side Effects: none

void
Sym_MddPrintStateForErrorTrace(
  Sym_Info_t *      symInfo,
  mdd_t *           mdd,
  char **           stateString
)
  Given an mdd representinga state, generate a string in the form x1=v1 x2=v2
  ...

  Side Effects: desired sting is padded to the end of stateString

mdd_t *
Sym_ModuleBuildInitialRegion(
  Sym_Info_t *      symInfo,
  Mdl_Module_t *    module
)
  build mdd for initial region of module

  Side Effects: none

void
Sym_ModuleBuildTransitionRelation(
  Sym_Info_t *      symInfo,
  Mdl_Module_t *    module
)
  build symbloic transition relation for a module. A conjunct is created for
  each atom and all conjuncts are stored in an array

  Side Effects: transtion relation is build and stored inside symInfo

boolean
Sym_ModuleMatchMddIds(
  Mdl_Module_t *    module1,
  Mdl_Module_t *    module2,
  Sym_Info_t *      symInfo1,
  Sym_Info_t *      symInfo2,
  array_t *         idArray1,
  array_t *         idArray2
)
  returns arrays of matching mdd ids for unprimed vars of two modules (through
  the arguments). The return value is true if every variable of module2 is
  also present in module 1 (this is the no-hidden variable case)

  Side Effects: matching ids are returned in corresponding indices of idArray1
  and idArray2

void
Sym_ModulePerformBFS(
  Tcl_Interp *      interp,
  Main_Manager_t *  mainManager,
  Mdl_Module_t *    module,
  array_t *         invNameArray,
  array_t *         typedExprArray
)
  Do invariant checking. This is the entry point for the sym invariant engine
  to be called from the inv package


Sym_Region_t *
Sym_RegionAlloc(
  Mdl_Module_t *    module,
  mdd_t *           regionMdd
)
  Allocate a region struct and set its module and image pointers to the
  arguments passed

  Side Effects: required

void
Sym_RegionFree(
  Sym_Region_t *    region
)
  optional

  Side Effects: required

void
Sym_RegionManagerAddModuleToSymInfo(
  Sym_RegionManager regionManager,
  Mdl_Module_t *    module,
  Sym_Info_t *      symInfo
)
  Given a module and its symInfo, add it to the region manager's
  moduleToSymInfo hash table

  Side Effects: none

Sym_RegionManager_t *
Sym_RegionManagerAlloc(

)
  A region manager manintains: 1. mapping from modules to their symInfos and
  2. region tables mapping region names to regions 3. region counter used to
  generate unique region names This routine allocates and returns a pointer to
  a region manager

  Side Effects: required

void
Sym_RegionManagerDeleteModuleToSymInfo(
  Sym_RegionManager regionManager,
  Mdl_Module_t *    module
)
  Given a module, delete it (and it's symInfo) from the region manager's
  moduleToSymInfo table. If the module is not in the table, this is a no-op

  Side Effects: none

void
Sym_RegionManagerFree(
  Sym_RegionManager regionManager
)
  optional

  Side Effects: required

void
Sym_RegionManagerIncrementCounter(
  Sym_RegionManager regionManager
)
  Given a pointer to the region manager, increment the value of the region
  counter

  Side Effects: none

unsigned long
Sym_RegionManagerReadCounter(
  Sym_RegionManager regionManager
)
  Given a pointer to the region manager, return the value of the region
  counter inside the manager

  Side Effects: none

Tcl_HashTable *
Sym_RegionManagerReadRegionTable(
  Sym_RegionManager regionManager
)
  Given a pointer to the region manager, return the region table (a Tcl hash
  table) associated with it. The region table hashes region names to
  SymRegionStruct vlaues. The user should NOT free this table

  Side Effects: none

Sym_Info_t *
Sym_RegionManagerReadSymInfo(
  Sym_RegionManager regionManager,
  Mdl_Module_t *    module
)
  Given a region manager and a module pointer, this routine returns a pointer
  to the module's symInfo it it exists, and 0 otherwise. The caller should NOT
  free this pointer

  Side Effects: SymRegionManagerAddModuleToSymInfo

int
Sym_Reinit(
  Tcl_Interp *      interp,
  Main_Manager_t *  manager
)
  This function is called when the user types a re-init command. Re-
  initialization is not yet supported by sym. Currently, this function does
  nothing

  Side Effects: none

int
Sym_StateInMddWithResidueMdd(
  mdd_manager *     mddManager,
  mdd_t *           mdd,
  array_t *         varIdArray,
  array_t *         valueArray,
  mdd_t **          returnMdd
)
  A state is given as an array of varids (corresponding to the unprimed
  variables) and an array of values (corresponding to the values of the
  variables). This function checks if the state is in the onset of the mdd.
  This function assumes that the values are within the domain size of the
  corresponding variables. (For example, the value of a boolean variable can
  only be 0 or 1, and the value of a enumerative variable with 3 values can
  only be 0, 1 or 2). It returns 0 if the state is not in the mdd, 1 if it is,
  or 2 if it is not determined. This happens when the state is a partial state
  and there is not enough information to check if it is in the mdd. In this
  case, the returnMdd pointer will point to the "residue mdd", i.e., the
  remaining mdd that is not resolved. Note: this implementation is based on
  cofactoring and in theory is inefficient. It should be replaced by a more
  efficient one which is based on traversal of the mdd.

  Side Effects: none

int
Sym_StateInMdd(
  mdd_manager *     mddManager,
  mdd_t *           mdd,
  array_t *         varIdArray,
  array_t *         valueArray
)
  A state is given as an array of varids (corresponding to the unprimed
  variables) and an array of values (corresponding to the values of the
  variables). This function checks if the state is in the onset of the mdd.
  This function assumes that the values are within the domain size of the
  corresponding variables. (For example, the value of a boolean variable can
  only be 0 or 1, and the value of a enumerative variable with 3 values can
  only be 0, 1 or 2). It returns 0 if the state is not in the mdd, 1 if it is,
  or 2 if it is not determined. This happens when the state is a partial state
  and there is not enough information to check if it is in the mdd. Note: this
  implementation is based on cofactoring and in theory is inefficient. It
  should be replaced by a more efficient one which is based on traversal of
  the mdd.

  Side Effects: none

Sym_Info_t *
Sym_SymInfoAlloc(
  Tcl_Interp *      interp,
  Mdl_Module_t *    module,
  mdd_manager *     manager
)
  Allocate and return a symInfo struct

  Side Effects: none

mdd_t *
Sym_SymInfoBuildFlatTrans(
  Sym_Info_t *      syminfo
)
  symInfo maintains a transition relation for a module as an array of
  conjuncts. This utility takes "and" of all the conjuncts and builds a flat
  transition relation

  Side Effects: none

void
Sym_SymInfoFree(
  Sym_Info_t *      symInfo
)
  Utility to free symInfo

  Side Effects: none

boolean
Sym_SymInfoLookupPrimedVariableId(
  Sym_Info_t *      symInfo,
  Var_Variable_t *  var,
  int *             id
)
  lookup primed mdd id for a variable

  Side Effects: none

boolean
Sym_SymInfoLookupUnprimedVariableId(
  Sym_Info_t *      symInfo,
  Var_Variable_t *  var,
  int *             id
)
  lookup unprimed mdd id for a variable

  Side Effects: none

mdd_t *
Sym_SymInfoReadConjunctForAtom(
  Sym_Info_t *      symInfo,
  Atm_Atom_t *      atom
)
  read the conjunct (transtion relation) for the given atom

  Side Effects: none

array_t *
Sym_SymInfoReadConjuncts(
  Sym_Info_t *      symInfo
)
  read the conjuncts from symInfo

  Side Effects: none

st_table *
Sym_SymInfoReadIdToVar(
  Sym_Info_t *      symInfo
)
  read the idToVar table from symInfo

  Side Effects: none

Img_ImageInfo_t *
Sym_SymInfoReadImgInfo(
  Sym_Info_t *      symInfo
)
  read the image info from symInfo

  Side Effects: none

mdd_manager *
Sym_SymInfoReadManager(
  Sym_Info_t *      symInfo
)
  read the mdd manager from symInfo

  Side Effects: none

array_t *
Sym_SymInfoReadPrimedIdArray(
  Sym_Info_t *      symInfo
)
  read the primedIdArray array

  Side Effects: none

array_t *
Sym_SymInfoReadQuantifyIdArray(
  Sym_Info_t *      symInfo
)
  read the quantifyIdArray array

  Side Effects: none

array_t *
Sym_SymInfoReadUnprimedIdArray(
  Sym_Info_t *      symInfo
)
  read the unprimedIdArray array

  Side Effects: none

st_table *
Sym_SymInfoReadVarToPrimedId(
  Sym_Info_t *      symInfo
)
  read the varToPrimedId st_table

  Side Effects: none

st_table *
Sym_SymInfoReadVarToUnprimedId(
  Sym_Info_t *      symInfo
)
  read the varToUnprimedId st_table

  Side Effects: none

void
Sym_SymInfoSetConjunctForAtom(
  Sym_Info_t *      symInfo,
  Atm_Atom_t *      atom,
  mdd_t *           atomMdd
)
  set the conjunct (transtion relation) for the given atom

  Side Effects: none

void
Sym_SymInfoSetImgInfo(
  Sym_Info_t *      symInfo,
  Img_ImageInfo_t * imgInfo
)
  read the image info from symInfo

  Side Effects: none

