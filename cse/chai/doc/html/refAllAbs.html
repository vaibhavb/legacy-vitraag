<HTML>
<HEAD><TITLE>ref package abstract</TITLE></HEAD>
<BODY>


<!-- Function Abstracts -->

<dl>
<DT> <A HREF="refAllDet.html#RefCheckCompositionalRefinementOneAtom" TARGET="MAIN"><CODE>RefCheckCompositionalRefinementOneAtom()</CODE></A>
<DD> driver for checking one step in the compositional refinement proof

<DT> <A HREF="refAllDet.html#RefCheckNohiddenRefinement" TARGET="MAIN"><CODE>RefCheckNohiddenRefinement()</CODE></A>
<DD> driver for checking refinement with no hidden variables
  in the specification

<DT> <A HREF="refAllDet.html#RefCheckSimulation" TARGET="MAIN"><CODE>RefCheckSimulation()</CODE></A>
<DD> driver for checking simulation

<DT> <A HREF="refAllDet.html#RefCheckTransitionInvariant" TARGET="MAIN"><CODE>RefCheckTransitionInvariant()</CODE></A>
<DD> Check refinement using transition invariant check on the
  implementation

<DT> <A HREF="refAllDet.html#RefConjunctsAddExtra" TARGET="MAIN"><CODE>RefConjunctsAddExtra()</CODE></A>
<DD> Add one mdd to the conjuncts array and return a new
                      conjuncts array

<DT> <A HREF="refAllDet.html#RefDumpIds" TARGET="MAIN"><CODE>RefDumpIds()</CODE></A>
<DD> dump and array of mdd Ids for debugging

<DT> <A HREF="refAllDet.html#RefGetFlatSpecTransRelation" TARGET="MAIN"><CODE>RefGetFlatSpecTransRelation()</CODE></A>
<DD> get flattened transition relation for specification in terms
                      of variables of implementation

<DT> <A HREF="refAllDet.html#RefMddArrayFree" TARGET="MAIN"><CODE>RefMddArrayFree()</CODE></A>
<DD> free MDD array

<DT> <A HREF="refAllDet.html#RefMddBuildNoChange" TARGET="MAIN"><CODE>RefMddBuildNoChange()</CODE></A>
<DD> Build MDD for no variables changing

<DT> <A HREF="refAllDet.html#RefMddBuildObseq" TARGET="MAIN"><CODE>RefMddBuildObseq()</CODE></A>
<DD> Build MDD for observational equivalence between two modules

<DT> <A HREF="refAllDet.html#RefPrimedIdsMerge" TARGET="MAIN"><CODE>RefPrimedIdsMerge()</CODE></A>
<DD> merge primed ids of two modules

<DT> <A HREF="refAllDet.html#RefUnprimedIdsMerge" TARGET="MAIN"><CODE>RefUnprimedIdsMerge()</CODE></A>
<DD> merge unprimed ids of two modules

<DT> <A HREF="refAllDet.html#Ref_CheckAtomRefinement" TARGET="MAIN"><CODE>Ref_CheckAtomRefinement()</CODE></A>
<DD> do one step of the compositional refinement proof

<DT> <A HREF="refAllDet.html#Ref_CheckImplCompatibility" TARGET="MAIN"><CODE>Ref_CheckImplCompatibility()</CODE></A>
<DD> check implementation compatibility between spec and impl

<DT> <A HREF="refAllDet.html#Ref_CheckNohiddenRefinement" TARGET="MAIN"><CODE>Ref_CheckNohiddenRefinement()</CODE></A>
<DD> Check if implModule is a refinement of specModule
                      with the assumption that all history dependent
                      variables of specModule are also present in implModule

<DT> <A HREF="refAllDet.html#Ref_CheckSimulationUsingPre" TARGET="MAIN"><CODE>Ref_CheckSimulationUsingPre()</CODE></A>
<DD> Check if specModule is a simulates of implModule

<DT> <A HREF="refAllDet.html#Ref_End" TARGET="MAIN"><CODE>Ref_End()</CODE></A>
<DD> End function

<DT> <A HREF="refAllDet.html#Ref_Init" TARGET="MAIN"><CODE>Ref_Init()</CODE></A>
<DD> Init function for tcl.

<DT> <A HREF="refAllDet.html#Ref_IsMemberOfAtomList" TARGET="MAIN"><CODE>Ref_IsMemberOfAtomList()</CODE></A>
<DD> test for membership in list of atoms

<DT> <A HREF="refAllDet.html#Ref_IsMemberOfNameList" TARGET="MAIN"><CODE>Ref_IsMemberOfNameList()</CODE></A>
<DD> test for membership in list of names

<DT> <A HREF="refAllDet.html#Ref_LookupVarList" TARGET="MAIN"><CODE>Ref_LookupVarList()</CODE></A>
<DD> Lookup variable by name from a list of variables

<DT> <A HREF="refAllDet.html#Ref_Reinit" TARGET="MAIN"><CODE>Ref_Reinit()</CODE></A>
<DD> Reinit function

<DT> <A HREF="refAllDet.html#Ref_VariableReadControlAtom" TARGET="MAIN"><CODE>Ref_VariableReadControlAtom()</CODE></A>
<DD> Ref_VariableReadControlAtom

</DL>

<HR>

Last updated on 1031104 18h39
</BODY></HTML>
