<HTML>
<HEAD><TITLE>The atlp package</TITLE></HEAD>
<BODY>

<DL>
<dt><pre>
<A NAME="Atlp_AgentAllocWithName"></A>
Atlp_Agent_t * <I></I>
<B>Atlp_AgentAllocWithName</B>(
  char * <b>name</b> <i></i>
)
</pre>
<dd> This function allocates a new Atlp_Agent_t. Only the
  name is set, while all the other members are set to NIL.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_AgentAlloc">Atlp_AgentAlloc</a>
<a href="#Atlp_AgentFree">Atlp_AgentFree</a>
</code>

<dt><pre>
<A NAME="Atlp_AgentAlloc"></A>
Atlp_Agent_t * <I></I>
<B>Atlp_AgentAlloc</B>(
  char * <b>name</b>, <i></i>
  boolean  <b>isAgent</b>, <i></i>
  Atm_Atom_t * <b>atom</b> <i></i>
)
</pre>
<dd> Allocates an agent structure, and initialize all its
  members.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_AgentAllocWithType">Atlp_AgentAllocWithType</a>
<a href="#Atlp_AgentFree">Atlp_AgentFree</a>
</code>

<dt><pre>
<A NAME="Atlp_AgentFree"></A>
void <I></I>
<B>Atlp_AgentFree</B>(
  Atlp_Agent_t * <b>agent</b> <i></i>
)
</pre>
<dd> It frees an agent structure.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_AgentIsAgentSet"></A>
void <I></I>
<B>Atlp_AgentIsAgentSet</B>(
  Atlp_Agent_t * <b>agent</b>, <i></i>
  boolean  <b>value</b> <i></i>
)
</pre>
<dd> Sets the isAgent flag.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_AgentIsAgent"></A>
boolean <I></I>
<B>Atlp_AgentIsAgent</B>(
  Atlp_Agent_t * <b>agent</b> <i></i>
)
</pre>
<dd> This function returns TRUE if the agent specified is
  an agent, FALSE otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_AgentReadAtom"></A>
Atm_Atom_t * <I></I>
<B>Atlp_AgentReadAtom</B>(
  Atlp_Agent_t * <b>agent</b> <i></i>
)
</pre>
<dd> This function returns the atom of the agent.
<p>

<dd> <b>Side Effects</b> Do not free the atom.
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_AgentReadName"></A>
char * <I></I>
<B>Atlp_AgentReadName</B>(
  Atlp_Agent_t * <b>agent</b> <i></i>
)
</pre>
<dd> This function returns the name of the agent.
<p>

<dd> <b>Side Effects</b> Do not free the name.
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_FileParseFormula"></A>
lsList <I></I>
<B>Atlp_FileParseFormula</B>(
  Atlp_Manager_t * <b>manager</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Parses a file containing a set of semicolon-ending ATL
  formulas, and returns an array of Atlp_Formula_t representing those
  formulas.  If an error is detected while parsing the file, the routine frees
  any allocated memory and returns NULL.
<p>

<dt><pre>
<A NAME="Atlp_FlushStates"></A>
void <I></I>
<B>Atlp_FlushStates</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Frees States field of Atlp_Formula_t recursively
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaFree">Atlp_FormulaFree</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaArrayConvertToDAG"></A>
array_t * <I></I>
<B>Atlp_FormulaArrayConvertToDAG</B>(
  array_t * <b>formulaArray</b> <i></i>
)
</pre>
<dd> The function hashes each subformula of a formula (including the
  formula itself) into a uniqueTable. It returns an array containing the roots
  of the multi-rooted DAG thus created by the sharing of the subformulae. It
  is okay to call this function with an empty array (in which case an empty
  array is returned), but it is an error to call it with a NULL array.
<p>

<dd> <b>Side Effects</b> A formula in formulaArray might be freed if it had been
  encountered as a subformula of some other formula. Other formulae in
  formulaArray might be present in the returned array. Therefore, the formulae
  in formulaArray should not be freed. Only formulaArray itself should be
  freed.
<p>

<dt><pre>
<A NAME="Atlp_FormulaArrayConvertToExistentialFormTree"></A>
array_t * <I></I>
<B>Atlp_FormulaArrayConvertToExistentialFormTree</B>(
  array_t * <b>formulaArray</b> <i>of Atlp_Formula_t</i>
)
</pre>
<dd> Calls Atlp_FormulaConvertToExistentialForm on each formula. It
  is okay to call this function with an empty array (in which case an empty
  array is returned), but it is an error to call it with a NULL array.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaConvertToExistentialForm">Atlp_FormulaConvertToExistentialForm</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaArrayFree"></A>
void <I></I>
<B>Atlp_FormulaArrayFree</B>(
  array_t * <b>formulaArray</b> <i>of Atlp_Formula_t</i>
)
</pre>
<dd> Calls AtlpFormulaDecrementRefCount on each formula in
  formulaArray, and then frees the array itself.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaFree">Atlp_FormulaFree</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaConvertToExistentialForm"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaConvertToExistentialForm</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Converts a ATL formula to existential form.  That is, all
  universal path quantifiers are replaced with the appropriate combination of
  existential quantifiers and Boolean negation.  Also converts "finally"
  operators to "until" operators.<p>

  Returns a new formula that shares absolutely nothing with the original
  formula (not even the strings). Also, the new formula does not have any MDDs
  associated with it.  The "originalFormula" field of the returned formula is
  set to point to the formula passed as an argument.  In addition, if the
  original formula is of type AG, AX, AU, AF, or EF, the "converted flag" is
  set. Returns NULL if called with a NULL formula.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaArrayConvertToExistentialForm">Atlp_FormulaArrayConvertToExistentialForm</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaConvertToString"></A>
char * <I></I>
<B>Atlp_FormulaConvertToString</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Returns formula as a character string. All subformulas are
  delimited by parenthesis. The syntax used is the same as used by the ATL
  parser.  Does nothing if passed a NULL formula.
<p>

<dd> <b>Side Effects</b> Atlp_ExprConvertToString
<p>

<dt><pre>
<A NAME="Atlp_FormulaCreateWithAgents"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaCreateWithAgents</B>(
  Atlp_FormulaType  <b>type</b>, <i></i>
  void * <b>left</b>, <i></i>
  void * <b>right</b>, <i></i>
  lsList  <b>agentList</b> <i></i>
)
</pre>
<dd> Allocates a Atlp_Formula_t, and sets the 2 fields given as
  arguments.  If the type is Atlp_ID_c, then the left and right fields 
  should contain a pointer to a variable name and a pointer to a value 
  respectively. Otherwise, the two fields point to subformulas. refCount is
  set to 1. The states field is set to NULL, the converted flag is set to
  FALSE, and the originalFormula field is set to NULL.
<p>

<dd> <b>See Also</b> <code><a href="#AtlpFormulaDecrementRefCount">AtlpFormulaDecrementRefCount</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaCreate"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaCreate</B>(
  Atlp_FormulaType  <b>type</b>, <i></i>
  void * <b>left</b>, <i></i>
  void * <b>right</b> <i></i>
)
</pre>
<dd> Equivalent to Atlp_FormulaCreateWithAgents(type, left, right,
  NIL(lsList)).
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaCreateWithAgents">Atlp_FormulaCreateWithAgents</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaDAGConvertToExistentialFormDAG"></A>
array_t * <I></I>
<B>Atlp_FormulaDAGConvertToExistentialFormDAG</B>(
  array_t * <b>formulaDAG</b> <i></i>
)
</pre>
<dd> The function converts a DAG of ATL formulae to a DAG of
  existential ATL formulae. The function recursively converts each subformula
  of each of the formulae in the DAG and remembers the converted formula in
  the field states. It
  is okay to call this function with an empty array (in which case an empty
  array is returned), but it is an error to call it with a NULL array.
<p>

<dd> <b>See Also</b> <code><a href="#FormulaConvertToExistentialDAG">FormulaConvertToExistentialDAG</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaDup"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaDup</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Recursively duplicate a formula. Does nothing if the formula
  is NIL. Does not copy mdd for states, dbgInfo.
<p>

<dt><pre>
<A NAME="Atlp_FormulaFree"></A>
void <I></I>
<B>Atlp_FormulaFree</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> The function decrements the refCount of the formula. As a
  consequence, if the refCount becomes 0, the formula is freed.
<p>

<dd> <b>See Also</b> <code><a href="#AtlpFormulaFree">AtlpFormulaFree</a>
<a href="#AtlpDecrementRefCount">AtlpDecrementRefCount</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaObtainStates"></A>
mdd_t * <I></I>
<B>Atlp_FormulaObtainStates</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Gets a copy of the MDD representing the set of states for which
  this formula is true.  It is the user's responsibility to free this MDD. If
  the set of states has not yet been computed, then a NULL mdd_t is
  returned. It is an error to call this function on a NULL formula.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaSetStates">Atlp_FormulaSetStates</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaPrint"></A>
void <I></I>
<B>Atlp_FormulaPrint</B>(
  FILE * <b>fp</b>, <i></i>
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Prints a formula to a file. All subformulas are delimited by
  parenthesis. The syntax used is the same as used by the ATL parser.  Does
  nothing if passed a NULL formula.
<p>

<dt><pre>
<A NAME="Atlp_FormulaReadAgentList"></A>
lsList <I></I>
<B>Atlp_FormulaReadAgentList</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> It returns the agent list specified in the formula.
<p>

<dd> <b>Side Effects</b> Should not free the list
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadAtmExpr"></A>
Atm_Expr_t * <I></I>
<B>Atlp_FormulaReadAtmExpr</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> It returns the atmExpr in the formula.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadByName"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaReadByName</B>(
  char * <b>name</b>, <i></i>
  Atlp_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> This function returns a pointer to the formula
  with the given name.  If the formula is not found, a NIL pointer
  is returned.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadDebugData"></A>
void * <I></I>
<B>Atlp_FormulaReadDebugData</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Returns the debug data associated with a formula.  This data is
  uninterpreted by the atlp package.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaSetDbgInfo">Atlp_FormulaSetDbgInfo</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadLeftChild"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaReadLeftChild</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Gets the left child of a formula.  User must not free this
  formula. If a formula is a leaf formula, NIL(Atlp_Formula_t) is returned.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaReadRightChild">Atlp_FormulaReadRightChild</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadLeft"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaReadLeft</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> This function returns the left pointer of the formula.
  Should not free the pointer.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaReadRight">Atlp_FormulaReadRight</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadOriginalFormula"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaReadOriginalFormula</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Returns original formula corresponding to converted formula.
<p>

<dt><pre>
<A NAME="Atlp_FormulaReadRightChild"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaReadRightChild</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Gets the right child of a formula.  User must not free this
  formula. If a formula is a leaf formula, NIL(Atlp_Formula_t) is returned.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaReadLeftChild">Atlp_FormulaReadLeftChild</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadRight"></A>
Atlp_Formula_t * <I></I>
<B>Atlp_FormulaReadRight</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> This function returns the left pointer of the formula.
  Should not free the pointer.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaReadLeft">Atlp_FormulaReadLeft</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadType"></A>
Atlp_FormulaType <I></I>
<B>Atlp_FormulaReadType</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Gets the type of a formula. See atlp.h for all the types. It is
  an error to call this function on a NULL formula.
<p>

<dd> <b>See Also</b> <code><a href="#atlp.h">atlp.h</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaReadVariableName"></A>
char * <I></I>
<B>Atlp_FormulaReadVariableName</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Reads the variable name of a leaf formula. 
  It is an error to call this function on a non-leaf formula.
<p>

<dt><pre>
<A NAME="Atlp_FormulaSetAgentList"></A>
void <I></I>
<B>Atlp_FormulaSetAgentList</B>(
  Atlp_Formula_t * <b>formula</b>, <i></i>
  lsList  <b>agentList</b> <i></i>
)
</pre>
<dd> Sets the agentList field of the formula.
<p>

<dd> <b>Side Effects</b> It is an error to call this function with an NULL
  formula.
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_FormulaSetAtmExpr"></A>
void <I></I>
<B>Atlp_FormulaSetAtmExpr</B>(
  Atlp_Formula_t * <b>formula</b>, <i></i>
  Atm_Expr_t * <b>atmExpr</b> <i></i>
)
</pre>
<dd> Stores the atm_expr_t with the formula.  This expression
  only occurs with atomic formulas. It is usually built during the
  semantic check of the formula, and it should freed (by calling
  Atm_ExprFreeExpression) once the states for this formula is built. It is an
  error to call this function with a NULL formula.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code><a href="#McFormulaSemanticCheck">McFormulaSemanticCheck</a>
<a href="#Atlp_FormulaSetStates">Atlp_FormulaSetStates</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaSetDbgInfo"></A>
void <I></I>
<B>Atlp_FormulaSetDbgInfo</B>(
  Atlp_Formula_t * <b>formula</b>, <i></i>
  void * <b>data</b>, <i></i>
  Atlp_DbgInfoFreeFn  <b>freeFn</b> <i></i>
)
</pre>
<dd> Sets the debug information of a ATL formula.  The data is
  uninterpreted.  FreeFn is a pointer to a function that takes a formula as
  input and returns void.  FreeFn should free all the memory associated with
  the debug data; it is called when this formula is freed.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaReadDebugData">Atlp_FormulaReadDebugData</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaSetStates"></A>
void <I></I>
<B>Atlp_FormulaSetStates</B>(
  Atlp_Formula_t * <b>formula</b>, <i></i>
  mdd_t * <b>states</b> <i></i>
)
</pre>
<dd> Stores the MDD with the formula (a copy is not made, and hence,
  the caller should not later free this MDD). This MDD is intended to
  represent the set of states for which the formula is true. It is an error to
  call this function on a NULL formula.
<p>

<dd> <b>See Also</b> <code><a href="#Atlp_FormulaObtainStates">Atlp_FormulaObtainStates</a>
</code>

<dt><pre>
<A NAME="Atlp_FormulaTestIsConverted"></A>
boolean <I></I>
<B>Atlp_FormulaTestIsConverted</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Returns TRUE if formula was converted from a formula of type
  AG, AX, AU, AF, or EF via a call to
  Atlp_FormulaConvertToExistentialFormTree or
  Atlp_FormulaConvertToExistentialFormDAG. Otherwise, returns FALSE.
<p>

<dt><pre>
<A NAME="Atlp_FormulaTestIsQuantifierFree"></A>
boolean <I></I>
<B>Atlp_FormulaTestIsQuantifierFree</B>(
  Atlp_Formula_t * <b>formula</b> <i></i>
)
</pre>
<dd> Test if a atl formula has any path quantifiers in it;
  if so return false, else true.
<p>

<dt><pre>
<A NAME="Atlp_Init"></A>
int <I></I>
<B>Atlp_Init</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> It creates all the new tcl commands defined in this
  package. Also, it initialize the data structures used in this package.
<p>

<dd> <b>Side Effects</b> AtlpInitialize is called, and some global structures are
  allocated.
<p>

<dd> <b>See Also</b> <code><a href="#AtlpInitialize">AtlpInitialize</a>
</code>

<dt><pre>
<A NAME="Atlp_ManagerAlloc"></A>
Atlp_Manager_t * <I></I>
<B>Atlp_ManagerAlloc</B>(
   <b></b> <i></i>
)
</pre>
<dd> This function allocates the a new Atlp_Manager_t, and
  initialize the hash table in the manager.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_ManagerFree"></A>
void <I></I>
<B>Atlp_ManagerFree</B>(
  Atlp_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> This function frees a Atlp_Manager_t, frees the names of the
  atl formula, and decrements the ref count of the formula. If the reference
  count of the formula comes to zero, the formula is freed.
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_ManagerReadFormulaNames"></A>
array_t * <I></I>
<B>Atlp_ManagerReadFormulaNames</B>(
  Atlp_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> Given an ATL Manager, this function returns an array
  of all the formula names.
<p>

<dd> <b>Side Effects</b> User should free the array after use.  Note the
  content should not be freed.
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_ManagerReadFormulas"></A>
array_t * <I></I>
<B>Atlp_ManagerReadFormulas</B>(
  Atlp_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> Given an ATL Manager this function returns a list of
  all the ATL formula from the manager.
<p>

<dd> <b>Side Effects</b> This creates an array, which should be freed after use.
  Beware that the formula should not be freed.
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="Atlp_ReadAtlpManager"></A>
Atlp_Manager_t * <I></I>
<B>Atlp_ReadAtlpManager</B>(
   <b></b> <i></i>
)
</pre>
<dd> This function exports the Atlp Global Manager to the
  calling function. Casual user should not free the manager.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>


</DL>
<HR>
Last updated on 1031104 18h39
</BODY></HTML>
