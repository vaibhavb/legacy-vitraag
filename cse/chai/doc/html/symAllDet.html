<html>
<head><title>The sym package: all functions </title></head>
<body>


<HR>
<DL>
<dt><pre>
<A NAME="CommandBuildTrans"></A>
static int <I></I>
<B>CommandBuildTrans</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> Build transition relation for the given module. The transtion
                      relation is conjunctively decomposed - one conjunct per
		      atom and stored as part of the symInfo for the module
<p>

<dd> <b>Side Effects</b> 1. transition relation is stored as part of modules's SymInfo
                      2. If there is no symInfo, one is creared by 
		        executing the sym_static_order command.
<p>

<dd> <b>See Also</b> <code><a href="#CommandComputeInitSet">CommandComputeInitSet</a>
<a href="#CommandComputeReachSet">CommandComputeReachSet</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandComputeInitSet"></A>
static int <I></I>
<B>CommandComputeInitSet</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> Compute the mdd representing initial states of a module
<p>

<dd> <b>Side Effects</b> The initial region computed is added to the region manager's
                      region table
<p>

<dd> <b>See Also</b> <code><a href="#CommandComputeReachedSet">CommandComputeReachedSet</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandComputePostSet"></A>
static int <I></I>
<B>CommandComputePostSet</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> driver for one step image computation
<p>

<dd> <b>Side Effects</b> the image is stored in the region manager's
                      region table
<p>

<dd> <b>See Also</b> <code><a href="#CommandBuildTrans">CommandBuildTrans</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandComputeReachSet"></A>
static int <I></I>
<B>CommandComputeReachSet</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> Do symbolic reachability for a module. A transition 
                      relation must exist before thie function is called
<p>

<dd> <b>Side Effects</b> 1. The command could modify the status of the invariants
                      associated with the module on which it is executed.
		      2. The mdd represnting all reached states is added to the
		      region table (of the region manager)
<p>

<dd> <b>See Also</b> <code><a href="#CommandComputeInitSet">CommandComputeInitSet</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandComputeUnion"></A>
static int <I></I>
<B>CommandComputeUnion</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> typical usage is to union an image with an existing region
<p>

<dd> <b>Side Effects</b> The result of the union is added to the region manager's
                       region table
<p>

<dd> <b>See Also</b> <code><a href="#CommandComputePostSet">CommandComputePostSet</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandDynamicVarOrdering"></A>
static int <I></I>
<B>CommandDynamicVarOrdering</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> Implements the dynamic_var_ordering command.
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandPrintRegion"></A>
static int <I></I>
<B>CommandPrintRegion</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> Print the given region
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#CommandComputePostSet">CommandComputePostSet</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandReadOrder"></A>
static int <I></I>
<B>CommandReadOrder</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> Read an ordering of MDD variables into a file, and order
                      the MDD variables of a module accordingly
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#CommandWriteOrder">CommandWriteOrder</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="CommandWriteOrder"></A>
static int <I></I>
<B>CommandWriteOrder</B>(
  ClientData  <b>clientData</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>argc</b>, <i></i>
  char ** <b>argv</b> <i></i>
)
</pre>
<dd> Write the current ordering of MDD variables into a file
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#CommandReadOrder">CommandReadOrder</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="DynOrderTypeConvertToString"></A>
static char * <I></I>
<B>DynOrderTypeConvertToString</B>(
  bdd_reorder_type_t  <b>method</b> <i></i>
)
</pre>
<dd> Converts a dynamic ordering method type to a string.  This
  string must NOT be freed by the caller.
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="IntegersCompare"></A>
static int <I></I>
<B>IntegersCompare</B>(
  char ** <b>obj1</b>, <i></i>
  char ** <b>obj2</b> <i></i>
)
</pre>
<dd> Used to sort an array of integers in ascending order.
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="MddGroupVariables"></A>
void <I></I>
<B>MddGroupVariables</B>(
  mdd_manager * <b>mddMgr</b>, <i></i>
  int  <b>initMddId</b>, <i></i>
  int  <b>blockSize</b> <i></i>
)
</pre>
<dd> Group all bdd vars corresponding to mdd vars initMddId to
  initMddId + (blockSize-1) in a block which will not be reordered internally.
  Ths bdd's corresponding to these mdd's should be contiguous; if not the
  function will fail.
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="ModuleAssignMddIdsToVariables"></A>
static void <I></I>
<B>ModuleAssignMddIdsToVariables</B>(
  Mdl_Module_t * <b>module</b>, <i></i>
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>totalVarArray</b> <i></i>
)
</pre>
<dd> Create MDD variables according to the specified total ordering
<p>

<dd> <b>Side Effects</b> MDD variables are created for each of the module variables,
                      as specified by the total ordering

  SeeAlso            [
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="ModuleTotalOrderVariables"></A>
static array_t * <I></I>
<B>ModuleTotalOrderVariables</B>(
  Mdl_Module_t * <b>module</b>, <i></i>
  array_t * <b>varOrderArray</b> <i></i>
)
</pre>
<dd> Given a module and an array of variables (the order in which the 
                      variables are present in the array), pad remaining variables to the
		      end of the array
<p>

<dd> <b>Side Effects</b> Remaining variables are added to the end of the array
<p>

<dd> <b>See Also</b> <code><a href="#SymReadOrder">SymReadOrder</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="StringConvertToDynOrderType"></A>
static bdd_reorder_type_t <I></I>
<B>StringConvertToDynOrderType</B>(
  char * <b>string</b> <i></i>
)
</pre>
<dd> Converts a string to a dynamic ordering method type. If string
  is not "sift" or "window", then returns BDD_REORDER_NONE.
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="SymAssignmentBuildMddBoolean"></A>
mdd_t * <I></I>
<B>SymAssignmentBuildMddBoolean</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> Simply build MDDs for LHS and RHS separately and xnor them
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMVBuildAssignmentMdd">SymMVBuildAssignmentMdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symAssignMdd.c"TARGET="ABSTRACT"><CODE>symAssignMdd.c</CODE></A>

<dt><pre>
<A NAME="SymAssignmentBuildMddStandard"></A>
mdd_t * <I></I>
<B>SymAssignmentBuildMddStandard</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> A standard assignment assigns a scalar value (RHS)
                      to a scalar variable (LHS). Depending on whether the
		      LHS is boolean or multivalued, different functions are
		      called
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymAssignmentBuildMddBoolean">SymAssignmentBuildMddBoolean</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symAssignMdd.c"TARGET="ABSTRACT"><CODE>symAssignMdd.c</CODE></A>

<dt><pre>
<A NAME="SymBitVectorBuildAssignmentMdd"></A>
mdd_t * <I></I>
<B>SymBitVectorBuildAssignmentMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> This routine builds an MDD for a bit vector assignment
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymBitVectorBuildBooleanExpression">SymBitVectorBuildBooleanExpression</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symBitvec.c"TARGET="ABSTRACT"><CODE>symBitvec.c</CODE></A>

<dt><pre>
<A NAME="SymBitVectorBuildBooleanExpressionMdd"></A>
mdd_t * <I></I>
<B>SymBitVectorBuildBooleanExpressionMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> Given an expression of the form e1 <relop> e2, where
                      e1 and e2 are bit-vector expressions and
		      relop is a comparision operator, this
		      routne builds an MDD for the comparison
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymBitVetorBuildAssignmentMdd">SymBitVetorBuildAssignmentMdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symBitvec.c"TARGET="ABSTRACT"><CODE>symBitvec.c</CODE></A>

<dt><pre>
<A NAME="SymBitVectorBuildMddArrayForVar"></A>
array_t * <I></I>
<B>SymBitVectorBuildMddArrayForVar</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_ExprType  <b>varType</b>, <i></i>
  Var_Variable_t * <b>var</b> <i></i>
)
</pre>
<dd> Given a bitvector variable and its variable type (primed
  or unprimed), return an array of MDDs corresponding to its variables
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymBitVectorBuildMddArray">SymBitVectorBuildMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symBitvec.c"TARGET="ABSTRACT"><CODE>symBitvec.c</CODE></A>

<dt><pre>
<A NAME="SymBitVectorBuildMddArray"></A>
array_t * <I></I>
<B>SymBitVectorBuildMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> This routine builds an MDD array for a bit vector
  expression. Valid bit vector expressions are
  0. c, a bit vector constant
  1. v,a bit vector variable
  2. a[index
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymBitVectorBuildBooleanExpressionMdd">SymBitVectorBuildBooleanExpressionMdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symBitvec.c"TARGET="ABSTRACT"><CODE>symBitvec.c</CODE></A>

<dt><pre>
<A NAME="SymCreateMddVariable"></A>
int <I></I>
<B>SymCreateMddVariable</B>(
  mdd_manager * <b>manager</b>, <i></i>
  int  <b>range</b> <i></i>
)
</pre>
<dd> given a range create an MDD variable for that range
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymExprBuildExprConstMdd"></A>
mdd_t * <I></I>
<B>SymExprBuildExprConstMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Expr_t * <b>expr</b>, <i></i>
  int  <b>c</b>, <i></i>
  int  <b>nVals</b> <i></i>
)
</pre>
<dd> Given an expression e and a constant c,
                      build MDD for the boolean expression e = c.
		      Note that e and c are multivalued
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_ExprBuildMdd">Sym_ExprBuildMdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symExprMdd.c"TARGET="ABSTRACT"><CODE>symExprMdd.c</CODE></A>

<dt><pre>
<A NAME="SymExprBuildMvf"></A>
Mvf_Function_t * <I></I>
<B>SymExprBuildMvf</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> An mvf is an array of mdds.
                      A multivalued function can be represented with such an array of size
		      equal to the number of values that could be taken by the expression.
		      We build such an mvf for the given expression. For information on mvf
		      see the mvf package (borrowed, with thanks, from VIS)
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMV.c"TARGET="ABSTRACT"><CODE>symMV.c</CODE></A>

<dt><pre>
<A NAME="SymGetArrayElementVar"></A>
Var_Variable_t * <I></I>
<B>SymGetArrayElementVar</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  int  <b>value</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetArrayId"></A>
int <I></I>
<B>SymGetArrayId</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  Atm_ExprType  <b>pOrUnp</b>, <i></i>
  int  <b>value</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetArrayNvals"></A>
int <I></I>
<B>SymGetArrayNvals</B>(
  Var_Variable_t * <b>var</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetConstant"></A>
int <I></I>
<B>SymGetConstant</B>(
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> The key here is to return the "index" of the constant
  value in the case of enumerated data types
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetMddLiteral"></A>
mdd_t * <I></I>
<B>SymGetMddLiteral</B>(
  mdd_manager * <b>manager</b>, <i></i>
  int  <b>id</b>, <i></i>
  int  <b>value</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetNvals"></A>
int <I></I>
<B>SymGetNvals</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  int  <b>id</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetRelExprMdd"></A>
mdd_t * <I></I>
<B>SymGetRelExprMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_ExprType  <b>exprType</b>, <i></i>
  int  <b>lvarid</b>, <i></i>
  int  <b>rvarid</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetTopMddId"></A>
int <I></I>
<B>SymGetTopMddId</B>(
  mdd_t * <b>m</b>, <i></i>
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetVariableIdConstantAndPlus"></A>
void <I></I>
<B>SymGetVariableIdConstantAndPlus</B>(
  Atm_Expr_t * <b>expr</b>, <i></i>
  int * <b>varId</b>, <i></i>
  int * <b>c</b>, <i></i>
  boolean * <b>isPlus</b>, <i></i>
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> utility to get the components of an expression of the
  form v + c or v - c
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymGetVariableId"></A>
int <I></I>
<B>SymGetVariableId</B>(
  Atm_Expr_t * <b>expr</b>, <i></i>
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> utility to get the mdd variable id corresponding to the expression
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymInfoReadModule"></A>
Mdl_Module_t * <I></I>
<B>SymInfoReadModule</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymIsMultiValuedVariable"></A>
boolean <I></I>
<B>SymIsMultiValuedVariable</B>(
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> is the given expression a multi-valued variable?
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymIsNumEnumRangeConstant"></A>
boolean <I></I>
<B>SymIsNumEnumRangeConstant</B>(
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> utility to check if a given expression is a num or enum or range
                      constant
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymIsUnprimedId"></A>
boolean <I></I>
<B>SymIsUnprimedId</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  int  <b>id</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymMVBuildAssignmentMdd"></A>
mdd_t * <I></I>
<B>SymMVBuildAssignmentMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> Build MDD for multi valued assignment
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMV.c"TARGET="ABSTRACT"><CODE>symMV.c</CODE></A>

<dt><pre>
<A NAME="SymMVBuildBooleanExpressionMdd"></A>
mdd_t * <I></I>
<B>SymMVBuildBooleanExpressionMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> Given a multivalued expression of the form
                      e1 <relop> e2, where e1 and e2 are multivalued expressions
		      and <relop> is a comparison operator,
		      this routine builds an MDD for the comparison
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMV.c"TARGET="ABSTRACT"><CODE>symMV.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayAndComponents"></A>
mdd_t * <I></I>
<B>SymMddArrayAndComponents</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>mddArray</b> <i></i>
)
</pre>
<dd> Given an mdd array, perform and-ing of all
                      components and return the result  as an MDD
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayAndComponents">SymMddArrayAndComponents</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayAndMddArray"></A>
array_t * <I></I>
<B>SymMddArrayAndMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise and-ing and return the result
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayOrMddArray">SymMddArrayOrMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayAndMdd"></A>
array_t * <I></I>
<B>SymMddArrayAndMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  mdd_t * <b>m</b> <i></i>
)
</pre>
<dd> Given an mdd array and an mdd, 
                      perform and on each element of the array with the given mdd,
		      and return the result as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayAndMddArray">SymMddArrayAndMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayCompareEqual"></A>
mdd_t * <I></I>
<B>SymMddArrayCompareEqual</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise equality checking
		      and return the result as an MDD.
		      One could interpret the result as a collection of
		      conditions on the variables that make the MDD arrays
		      equal
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayCompareLesser">SymMddArrayCompareLesser</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayCompareGreaterEqual"></A>
mdd_t * <I></I>
<B>SymMddArrayCompareGreaterEqual</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform "greater than or equal" checking
		      and return the result as an MDD. (The lsb is at bit zero.)
		      One could interpret the result as a collection of
		      conditions on the variables that make the first
		      MDD array greater than or equal to the second
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayCompareGreater">SymMddArrayCompareGreater</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayCompareGreater"></A>
mdd_t * <I></I>
<B>SymMddArrayCompareGreater</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform greater than checking 
		      and return the result as an MDD.
                      (The lsb is at bit zero.)
		      One could interpret the result as a collection of
		      conditions on the variables that make the first
		      MDD array greater than the second
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayCompareLesser">SymMddArrayCompareLesser</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayCompareLesserEqual"></A>
mdd_t * <I></I>
<B>SymMddArrayCompareLesserEqual</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform "lesser than or equal to" checking
		      and return the result as an MDD. (The lsb is the at bit zero).
		      One could interpret the result as a collection of
		      conditions on the variables that make the first
		      MDD array lesser than or equal to the second
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayCompareGreaterEqual">SymMddArrayCompareGreaterEqual</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayCompareLesser"></A>
mdd_t * <I></I>
<B>SymMddArrayCompareLesser</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform lesser than checking
		      and return the result as an MDD. (The lsb is at bit zero.)
		      One could interpret the result as a collection of
		      conditions on the variables that make the first
		      MDD array lesser than the second
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayCompareGreater">SymMddArrayCompareGreater</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayFree"></A>
void <I></I>
<B>SymMddArrayFree</B>(
  array_t * <b>mddArray</b> <i></i>
)
</pre>
<dd> Free the MDD array along with all MDDs contained in it
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayObtainConstant">SymMddArrayObtainConstant</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayImpliesMddArray"></A>
array_t * <I></I>
<B>SymMddArrayImpliesMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise implication and return the result
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayAndMddArray">SymMddArrayAndMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayMinusMddArray"></A>
array_t * <I></I>
<B>SymMddArrayMinusMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise subtraction(propogating 
		      borrow from the 0th bit to the last bit)
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayAddMddArray">SymMddArrayAddMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayNot"></A>
array_t * <I></I>
<B>SymMddArrayNot</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>mddArray</b> <i></i>
)
</pre>
<dd> Given an mdd array perform component-wise 
                      negation and return the result
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayNot">SymMddArrayNot</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayObtainConstant"></A>
array_t * <I></I>
<B>SymMddArrayObtainConstant</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  int  <b>n</b>, <i></i>
  boolean  <b>c</b> <i></i>
)
</pre>
<dd> Given a size n and a boolean c,  create and
                      return an MDD array of zeros or ones (as specified 
		      by c)
		      It is the caller's responsibilty to free this
		      array as well as the mdds in it
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayFree">SymMddArrayFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayOrMddArray"></A>
array_t * <I></I>
<B>SymMddArrayOrMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise or-ing and return the result
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayAndMddArray">SymMddArrayAndMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayOrMdd"></A>
array_t * <I></I>
<B>SymMddArrayOrMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  mdd_t * <b>m</b> <i></i>
)
</pre>
<dd> Given an mdd array and an mdd, 
                      perform or on each element of the array with the given mdd,
		      and return the result as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayAndMddArray">SymMddArrayAndMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayPlusMddArray"></A>
array_t * <I></I>
<B>SymMddArrayPlusMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise addition (propogating 
		      carry from the 0th bit to the last bit)
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayOrMddArray">SymMddArrayOrMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayPrint"></A>
void <I></I>
<B>SymMddArrayPrint</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b> <i></i>
)
</pre>
<dd> print all MDDs in the MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayPrint">SymMddArrayPrint</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayRedAnd"></A>
mdd_t * <I></I>
<B>SymMddArrayRedAnd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b> <i></i>
)
</pre>
<dd> do Reduction And of an Array
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayRedOr"></A>
mdd_t * <I></I>
<B>SymMddArrayRedOr</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b> <i></i>
)
</pre>
<dd> do Reduction Or of an Array
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayRedXor"></A>
mdd_t * <I></I>
<B>SymMddArrayRedXor</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b> <i></i>
)
</pre>
<dd> do Reduction Or of an Array
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayXnorMddArray"></A>
array_t * <I></I>
<B>SymMddArrayXnorMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise xnor-ing and return the result
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayOrMddArray">SymMddArrayOrMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddArrayXorMddArray"></A>
array_t * <I></I>
<B>SymMddArrayXorMddArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>array1</b>, <i></i>
  array_t * <b>array2</b> <i></i>
)
</pre>
<dd> Given two mdd arrays of equal length, 
                      perform component-wise xor-ing and return the result
		      as and MDD array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymMddArrayOrMddArray">SymMddArrayOrMddArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symMddArray.c"TARGET="ABSTRACT"><CODE>symMddArray.c</CODE></A>

<dt><pre>
<A NAME="SymMddInTrueSupport"></A>
boolean <I></I>
<B>SymMddInTrueSupport</B>(
  mdd_t * <b>m</b>, <i></i>
  int  <b>id</b>, <i></i>
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymModuleSearch"></A>
mdd_t * <I></I>
<B>SymModuleSearch</B>(
  Mdl_Module_t * <b>module</b>, <i></i>
  Sym_Info_t * <b>symInfo</b>, <i></i>
  boolean  <b>verbose</b>, <i></i>
  boolean  <b>checkInvariants</b>, <i></i>
  array_t * <b>invNameArray</b>, <i></i>
  array_t * <b>typedExprArray</b>, <i></i>
  Tcl_Interp * <b>interp</b>, <i></i>
  int  <b>maxNumSteps</b> <i></i>
)
</pre>
<dd> reachability + optionally invariant checking
<p>

<dd> <b>Side Effects</b> state of invariants may be changed
<p>

<dd> <b>See Also</b> <code><a href="#Sym_ModuleBuildTransitionRelation">Sym_ModuleBuildTransitionRelation</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="SymRangeReadDummyId"></A>
int <I></I>
<B>SymRangeReadDummyId</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  int  <b>range</b>, <i></i>
  int  <b>num</b> <i></i>
)
</pre>
<dd> We create twp dummy MDD ids for each value of range in a
                      multi valued expression. These MDD ids are used while
		      manipluating mvfs. This function looks up a dummy id
		      given the range value
<p>

<dd> <b>Side Effects</b> If the desired dummy id is not found, it is created 
                      and inserted into the rangeToDummyId table
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="SymReadOrder"></A>
array_t * <I></I>
<B>SymReadOrder</B>(
  FILE * <b>fp</b>, <i></i>
  Mdl_Module_t * <b>module</b> <i></i>
)
</pre>
<dd> Write variable order for module from a file
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymWriteOrder">SymWriteOrder</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="SymWriteOrder"></A>
void <I></I>
<B>SymWriteOrder</B>(
  FILE * <b>fp</b>, <i></i>
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> Write variable order for symInfo into a file
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymReadOrder">SymReadOrder</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_AssignmentBuildMdd"></A>
mdd_t * <I></I>
<B>Sym_AssignmentBuildMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Assign_t * <b>assign</b>, <i></i>
  st_table * <b>assignedVarTable</b> <i></i>
)
</pre>
<dd> Given an assignment, build an MDD for the assignment
<p>

<dd> <b>Side Effects</b> The variables that are assigned to, are added to the
                      assignedVarTable that is passed in
<p>

<dd> <b>See Also</b> <code><a href="#SymAssignmentBuildMddStandard">SymAssignmentBuildMddStandard</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symAssignMdd.c"TARGET="ABSTRACT"><CODE>symAssignMdd.c</CODE></A>

<dt><pre>
<A NAME="Sym_AtomBuildInitialRegion"></A>
mdd_t * <I></I>
<B>Sym_AtomBuildInitialRegion</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Atom_t * <b>atom</b> <i></i>
)
</pre>
<dd> build intial region for atom
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_AtomBuildTransitionRelation">Sym_AtomBuildTransitionRelation</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="Sym_AtomBuildTransitionRelation"></A>
mdd_t * <I></I>
<B>Sym_AtomBuildTransitionRelation</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Atom_t * <b>atom</b> <i></i>
)
</pre>
<dd> build transition relation for an atom
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_ModuleBuildTransitionRelation">Sym_ModuleBuildTransitionRelation</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="Sym_AtomsBuildPartialInitialRegion"></A>
mdd_t * <I></I>
<B>Sym_AtomsBuildPartialInitialRegion</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>atomArray</b>, <i></i>
  mdd_t * <b>partialState</b> <i></i>
)
</pre>
<dd> build mdd for partial initial region
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_AtomsComputePartialImage">Sym_AtomsComputePartialImage</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_AtomsComputePartialImage"></A>
mdd_t * <I></I>
<B>Sym_AtomsComputePartialImage</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>atomArray</b>, <i></i>
  mdd_t * <b>prevState</b>, <i></i>
  mdd_t * <b>partialState</b> <i></i>
)
</pre>
<dd> Compute partial image with respect to a set of atoms
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_AtomsBuildPartialInitialRegion">Sym_AtomsBuildPartialInitialRegion</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_DebugTracePrint"></A>
void <I></I>
<B>Sym_DebugTracePrint</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  array_t * <b>savedOnions</b>, <i></i>
  int  <b>step</b>, <i></i>
  mdd_t * <b>notInv</b>, <i></i>
  array_t * <b>eventIdArray</b>, <i></i>
  array_t * <b>histDependIdArray</b>, <i></i>
  char * <b>invName</b>, <i></i>
  char * <b>moduleName</b> <i></i>
)
</pre>
<dd> Given an array of MDDs (representing the onion ring),
                      the step at which the error occured,
		      the negation of the invariant that got violated,
		      arrays of event and history free ids of the module,
		      name of the invariant and module, this function
		      prints the debug trace.
		      It starts with the onion ring at the specified step and 
		      intersects it with the negation of the invariant. Then
		      it successivey does pre-image computations and finds 
		      a path to an initial state. Then it reverses the path and
		      and prints an error trace.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SymModuleSearch">SymModuleSearch</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="Sym_End"></A>
int <I></I>
<B>Sym_End</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> Currently this function does nothing. During a subsequent
                      cleanup this should be made to free all memeory allocated by sym
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_Init">Sym_Init</a>
<a href="#Sym_Reinit">Sym_Reinit</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_ExprBuildMdd"></A>
mdd_t * <I></I>
<B>Sym_ExprBuildMdd</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Expr_t * <b>expr</b> <i></i>
)
</pre>
<dd> This routined builds an MDD for an expression. Note that
                      the expression *must* evaluate to a boolean value in
                      order to be able to build an MDD. Otherwise
                      an error message is printed, and the routine aborts
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symExprMdd.c"TARGET="ABSTRACT"><CODE>symExprMdd.c</CODE></A>

<dt><pre>
<A NAME="Sym_Init"></A>
int <I></I>
<B>Sym_Init</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> This function is called when Mocha comes up and does the following:
                      1. Create hooks to sym package's functions for the
		      supported commands
		      2. Allocate memory for SymRegionManager and deposit it in the
		      main manager
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_End">Sym_End</a>
<a href="#Sym_Reinit">Sym_Reinit</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_MddPickMinterm"></A>
mdd_t  * <I></I>
<B>Sym_MddPickMinterm</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  mdd_t * <b>mdd</b> <i></i>
)
</pre>
<dd> utility to pick a minterm form a MDD
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_MddPrintCubesImplSpec"></A>
void <I></I>
<B>Sym_MddPrintCubesImplSpec</B>(
  Sym_Info_t * <b>implSymInfo</b>, <i></i>
  Sym_Info_t * <b>specSymInfo</b>, <i></i>
  mdd_t * <b>mdd</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Dump the given MDD as a sum of cubes.
                      Using symInfo, the MDD ids are translated to variable
		      names in the reactive module description
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_MddPrintRawCubes">Sym_MddPrintRawCubes</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_MddPrintCubes"></A>
void <I></I>
<B>Sym_MddPrintCubes</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  mdd_t * <b>mdd</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Dump the given MDD as a sum of cubes.
                      Using symInfo, the MDD ids are translated to variable
		      names in the reactive module description
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_MddPrintRawCubes">Sym_MddPrintRawCubes</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_MddPrintRawCubes"></A>
void <I></I>
<B>Sym_MddPrintRawCubes</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  mdd_t * <b>mdd</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Utility to dump mdds - in terms of raw mdd ids
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_MddPrintCubes">Sym_MddPrintCubes</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_MddPrintStateForErrorTrace"></A>
void <I></I>
<B>Sym_MddPrintStateForErrorTrace</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  mdd_t * <b>mdd</b>, <i></i>
  char ** <b>stateString</b> <i></i>
)
</pre>
<dd> Given an mdd representinga state, generate a string
                      in the form x1=v1 x2=v2 ...
<p>

<dd> <b>Side Effects</b> desired sting is padded to the end of stateString
<p>

<dd> <b>See Also</b> <code><a href="#Sym_MddPrintCubes">Sym_MddPrintCubes</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_ModuleBuildInitialRegion"></A>
mdd_t * <I></I>
<B>Sym_ModuleBuildInitialRegion</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Mdl_Module_t * <b>module</b> <i></i>
)
</pre>
<dd> build mdd for initial region of module
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_ModuleBuildTransitionRelation">Sym_ModuleBuildTransitionRelation</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="Sym_ModuleBuildTransitionRelation"></A>
void <I></I>
<B>Sym_ModuleBuildTransitionRelation</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Mdl_Module_t * <b>module</b> <i></i>
)
</pre>
<dd> build symbloic transition relation for a module.
                      A conjunct is created for each atom and all conjuncts
		      are stored in an array
<p>

<dd> <b>Side Effects</b> transtion relation is build and stored inside symInfo
<p>

<dd> <b>See Also</b> <code><a href="#SymSearchModule">SymSearchModule</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="Sym_ModuleMatchMddIds"></A>
boolean <I></I>
<B>Sym_ModuleMatchMddIds</B>(
  Mdl_Module_t * <b>module1</b>, <i></i>
  Mdl_Module_t * <b>module2</b>, <i></i>
  Sym_Info_t * <b>symInfo1</b>, <i></i>
  Sym_Info_t * <b>symInfo2</b>, <i></i>
  array_t * <b>idArray1</b>, <i></i>
  array_t * <b>idArray2</b> <i></i>
)
</pre>
<dd> returns arrays of matching mdd ids for unprimed vars of
                        two modules (through the arguments). The return value is
			true if every variable of module2 is also present
			in module 1 (this is the no-hidden variable case)
<p>

<dd> <b>Side Effects</b> matching ids are returned in corresponding indices of
                       idArray1 and idArray2
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_ModulePerformBFS"></A>
void <I></I>
<B>Sym_ModulePerformBFS</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>mainManager</b>, <i></i>
  Mdl_Module_t * <b>module</b>, <i></i>
  array_t * <b>invNameArray</b>, <i></i>
  array_t * <b>typedExprArray</b> <i></i>
)
</pre>
<dd> Do invariant checking. This is the entry point
                      for the sym invariant engine to be called from
		      the inv package
<p>

<dd> <b>See Also</b> <code><a href="#Sym_ModuleBuildTransitionRelation">Sym_ModuleBuildTransitionRelation</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#sym.c"TARGET="ABSTRACT"><CODE>sym.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionAlloc"></A>
Sym_Region_t * <I></I>
<B>Sym_RegionAlloc</B>(
  Mdl_Module_t * <b>module</b>, <i></i>
  mdd_t * <b>regionMdd</b> <i></i>
)
</pre>
<dd> Allocate a region struct and set its module
                      and image pointers to the arguments passed
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionFree"></A>
void <I></I>
<B>Sym_RegionFree</B>(
  Sym_Region_t * <b>region</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerAddModuleToSymInfo"></A>
void <I></I>
<B>Sym_RegionManagerAddModuleToSymInfo</B>(
  Sym_RegionManager_t * <b>regionManager</b>, <i></i>
  Mdl_Module_t * <b>module</b>, <i></i>
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> Given a module and its symInfo, add it to the region manager's
                      moduleToSymInfo hash table
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_RegionManagerReadSymInfo">Sym_RegionManagerReadSymInfo</a>
<a href="#Sym_RegionManagerDeleteModuleToSymInfo">Sym_RegionManagerDeleteModuleToSymInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerAlloc"></A>
Sym_RegionManager_t * <I></I>
<B>Sym_RegionManagerAlloc</B>(
   <b></b> <i></i>
)
</pre>
<dd> A region manager manintains:
                     1. mapping from modules to their symInfos and 
		     2. region tables mapping region names to regions
		     3. region counter used to generate unique region names

		     This routine allocates and returns a 
		     pointer to a region manager
<p>

<dd> <b>Side Effects</b> required
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerDeleteModuleToSymInfo"></A>
void <I></I>
<B>Sym_RegionManagerDeleteModuleToSymInfo</B>(
  Sym_RegionManager_t * <b>regionManager</b>, <i></i>
  Mdl_Module_t * <b>module</b> <i></i>
)
</pre>
<dd> Given a module, delete it (and it's symInfo) from the
                      region manager's moduleToSymInfo table. If the module is
		      not in the table, this is a no-op
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_RegionManagerAddModuleToSymInfo">Sym_RegionManagerAddModuleToSymInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerFree"></A>
void <I></I>
<B>Sym_RegionManagerFree</B>(
  Sym_RegionManager_t * <b>regionManager</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerIncrementCounter"></A>
void <I></I>
<B>Sym_RegionManagerIncrementCounter</B>(
  Sym_RegionManager_t * <b>regionManager</b> <i></i>
)
</pre>
<dd> Given a pointer to the region manager, increment
                      the value of the region counter
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_RegionManagerReadCounter">Sym_RegionManagerReadCounter</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerReadCounter"></A>
unsigned long <I></I>
<B>Sym_RegionManagerReadCounter</B>(
  Sym_RegionManager_t * <b>regionManager</b> <i></i>
)
</pre>
<dd> Given a pointer to the region manager, return
                      the value of the region counter inside the manager
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_RegionManagerReadRegionTable">Sym_RegionManagerReadRegionTable</a>
<a href="#Sym_RegionManagerIncrementCounter">Sym_RegionManagerIncrementCounter</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerReadRegionTable"></A>
Tcl_HashTable * <I></I>
<B>Sym_RegionManagerReadRegionTable</B>(
  Sym_RegionManager_t * <b>regionManager</b> <i></i>
)
</pre>
<dd> Given a pointer to the region manager, return the
                      region table (a Tcl hash table) associated with it.
		      The region table hashes region names to SymRegionStruct
		      vlaues. The user should NOT free this table
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_RegionManagerReadCounter">Sym_RegionManagerReadCounter</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_RegionManagerReadSymInfo"></A>
Sym_Info_t * <I></I>
<B>Sym_RegionManagerReadSymInfo</B>(
  Sym_RegionManager_t * <b>regionManager</b>, <i></i>
  Mdl_Module_t * <b>module</b> <i></i>
)
</pre>
<dd> Given a region manager and a module pointer,
                      this routine returns a pointer to the module's
		      symInfo it it exists, and 0 otherwise.
		      The caller should NOT free this pointer
<p>

<dd> <b>Side Effects</b> SymRegionManagerAddModuleToSymInfo
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_Reinit"></A>
int <I></I>
<B>Sym_Reinit</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Main_Manager_t * <b>manager</b> <i></i>
)
</pre>
<dd> This function is called when the user types a re-init command. 
                      Re-initialization is not yet supported by sym.
		      Currently, this function does nothing
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_Init">Sym_Init</a>
<a href="#Sym_End">Sym_End</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="Sym_StateInMddWithResidueMdd"></A>
int <I></I>
<B>Sym_StateInMddWithResidueMdd</B>(
  mdd_manager * <b>mddManager</b>, <i></i>
  mdd_t * <b>mdd</b>, <i></i>
  array_t * <b>varIdArray</b>, <i></i>
  array_t * <b>valueArray</b>, <i></i>
  mdd_t ** <b>returnMdd</b> <i></i>
)
</pre>
<dd> A state is given as an array of varids (corresponding to
                      the unprimed variables) and an array of values
                      (corresponding to the values of the variables). This
                      function checks if the state is in the onset of the mdd.
                      This function assumes that the values are within the
                      domain size of the corresponding variables. (For
                      example, the value of a boolean variable can only be
                      0 or 1, and the value of a enumerative variable with
                      3 values can only be 0, 1 or 2).

		      It returns 0 if the state is not in the mdd, 1 if it is,
		      or 2 if it is not determined.  This happens when
		      the state is a partial state and there is not enough
		      information to check if it is in the mdd.  In this case,
                      the returnMdd pointer will point to the "residue mdd",
                      i.e., the remaining mdd that is not resolved.
                     

		      Note: this implementation is based on cofactoring and 
		      in theory is inefficient. It should be
		      replaced by a more efficient one which is based on traversal
		      of the mdd.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_StateInMdd"></A>
int <I></I>
<B>Sym_StateInMdd</B>(
  mdd_manager * <b>mddManager</b>, <i></i>
  mdd_t * <b>mdd</b>, <i></i>
  array_t * <b>varIdArray</b>, <i></i>
  array_t * <b>valueArray</b> <i></i>
)
</pre>
<dd> A state is given as an array of varids (corresponding to
                      the unprimed variables) and an array of values
                      (corresponding to the values of the variables). This
                      function checks if the state is in the onset of the mdd.
                      This function assumes that the values are within the
                      domain size of the corresponding variables. (For
                      example, the value of a boolean variable can only be
                      0 or 1, and the value of a enumerative variable with
                      3 values can only be 0, 1 or 2).

		      It returns 0 if the state is not in the mdd, 1 if it is,
		      or 2 if it is not determined.  This happens when
		      the state is a partial state and there is not enough
		      information to check if it is in the mdd.                       

		      Note: this implementation is based on cofactoring and 
		      in theory is inefficient. It should be
		      replaced by a more efficient one which is based on traversal
		      of the mdd.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoAlloc"></A>
Sym_Info_t * <I></I>
<B>Sym_SymInfoAlloc</B>(
  Tcl_Interp * <b>interp</b>, <i></i>
  Mdl_Module_t * <b>module</b>, <i></i>
  mdd_manager * <b>manager</b> <i></i>
)
</pre>
<dd> Allocate and return a symInfo struct
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoFree">Sym_SymInfoFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoBuildFlatTrans"></A>
mdd_t * <I></I>
<B>Sym_SymInfoBuildFlatTrans</B>(
  Sym_Info_t * <b>syminfo</b> <i></i>
)
</pre>
<dd> symInfo maintains a transition relation for a module
                      as an array of conjuncts.  This utility takes "and"
		      of all the conjuncts and builds a flat
		      transition relation
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoFree"></A>
void <I></I>
<B>Sym_SymInfoFree</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> Utility to free symInfo
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoAlloc">Sym_SymInfoAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoLookupPrimedVariableId"></A>
boolean <I></I>
<B>Sym_SymInfoLookupPrimedVariableId</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  int * <b>id</b> <i></i>
)
</pre>
<dd> lookup primed mdd id for a variable
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoLookupUnprimedVariableId">Sym_SymInfoLookupUnprimedVariableId</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoLookupUnprimedVariableId"></A>
boolean <I></I>
<B>Sym_SymInfoLookupUnprimedVariableId</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  int * <b>id</b> <i></i>
)
</pre>
<dd> lookup unprimed mdd id for a variable
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoLookupPrimedVariableId">Sym_SymInfoLookupPrimedVariableId</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadConjunctForAtom"></A>
mdd_t * <I></I>
<B>Sym_SymInfoReadConjunctForAtom</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Atom_t * <b>atom</b> <i></i>
)
</pre>
<dd> read the conjunct  (transtion relation) for the given atom
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadManager">Sym_SymInfoReadManager</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadConjuncts"></A>
array_t * <I></I>
<B>Sym_SymInfoReadConjuncts</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the conjuncts from symInfo
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sum_SymInfoReadImgInfo">Sum_SymInfoReadImgInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadIdToVar"></A>
st_table * <I></I>
<B>Sym_SymInfoReadIdToVar</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the idToVar table from symInfo
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadImgInfo"></A>
Img_ImageInfo_t * <I></I>
<B>Sym_SymInfoReadImgInfo</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the image info from symInfo
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadUnprimedArray">Sym_SymInfoReadUnprimedArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadManager"></A>
mdd_manager * <I></I>
<B>Sym_SymInfoReadManager</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the mdd manager from symInfo
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadConjuncts">Sym_SymInfoReadConjuncts</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadPrimedIdArray"></A>
array_t * <I></I>
<B>Sym_SymInfoReadPrimedIdArray</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the primedIdArray array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadUnprimedIdArray">Sym_SymInfoReadUnprimedIdArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadQuantifyIdArray"></A>
array_t * <I></I>
<B>Sym_SymInfoReadQuantifyIdArray</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the quantifyIdArray array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadUnprimedIdArray">Sym_SymInfoReadUnprimedIdArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadUnprimedIdArray"></A>
array_t * <I></I>
<B>Sym_SymInfoReadUnprimedIdArray</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the unprimedIdArray array
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadPrimedIdArray">Sym_SymInfoReadPrimedIdArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadVarToPrimedId"></A>
st_table * <I></I>
<B>Sym_SymInfoReadVarToPrimedId</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the varToPrimedId st_table
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadVarToUnprimedId">Sym_SymInfoReadVarToUnprimedId</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoReadVarToUnprimedId"></A>
st_table * <I></I>
<B>Sym_SymInfoReadVarToUnprimedId</B>(
  Sym_Info_t * <b>symInfo</b> <i></i>
)
</pre>
<dd> read the varToUnprimedId st_table
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadVarToPrimedId">Sym_SymInfoReadVarToPrimedId</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoSetConjunctForAtom"></A>
void <I></I>
<B>Sym_SymInfoSetConjunctForAtom</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Atm_Atom_t * <b>atom</b>, <i></i>
  mdd_t * <b>atomMdd</b> <i></i>
)
</pre>
<dd> set the conjunct  (transtion relation) for the given atom
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadManager">Sym_SymInfoReadManager</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="Sym_SymInfoSetImgInfo"></A>
void <I></I>
<B>Sym_SymInfoSetImgInfo</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Img_ImageInfo_t * <b>imgInfo</b> <i></i>
)
</pre>
<dd> read the image info from symInfo
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Sym_SymInfoReadUnprimedArray">Sym_SymInfoReadUnprimedArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symUtil.c"TARGET="ABSTRACT"><CODE>symUtil.c</CODE></A>

<dt><pre>
<A NAME="VarBuildBddIdArray"></A>
static array_t * <I></I>
<B>VarBuildBddIdArray</B>(
  Sym_Info_t * <b>symInfo</b>, <i></i>
  Var_Variable_t * <b>var</b>, <i></i>
  boolean  <b>primed</b> <i></i>
)
</pre>
<dd> Returns an array (of int's) of the levels of the BDD variables
  corresponding to the MDD variable of a node.  The level of a BDD variable is
  it place in the current variable ordering of the BDD manager.  The returned
  array is sorted in ascending order.  It is the responsibility of the caller
  to free this array.
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="VarOrderIsInArray"></A>
static int <I></I>
<B>VarOrderIsInArray</B>(
  array_t * <b>varOrderArray</b>, <i></i>
  VarOrder_t * <b>varOrder</b> <i></i>
)
</pre>
<dd> check if a variable is in a varOrderArray
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>

<dt><pre>
<A NAME="VarOrdersCompareBddIdArray"></A>
static int <I></I>
<B>VarOrdersCompareBddIdArray</B>(
  lsGeneric  <b>node1</b>, <i></i>
  lsGeneric  <b>node2</b> <i></i>
)
</pre>
<dd> Used to sort an array of nodes in ascending order of lowest BDD
  level.
<p>

<DD> <B>Defined in </B> <A HREF="symAllFile.html#symIntf.c"TARGET="ABSTRACT"><CODE>symIntf.c</CODE></A>


</DL>
<HR>
Last updated on 1031104 18h39
</BODY></HTML>
